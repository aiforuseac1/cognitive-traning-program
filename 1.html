<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®¤çŸ¥èƒ½åŠ›åˆ†æï¼šæ•°å­—é…å¯¹æŒ‘æˆ˜ v3.0 Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary-glow: rgba(78, 205, 196, 0.8);
            --secondary-glow: rgba(102, 126, 234, 0.6);
            /* [æ–°å¢] è¯„çº§é¢œè‰²ä½“ç³» */
            --tier-color-1: #e74c3c; /* æ–°æ‰‹ */
            --tier-color-2: #f39c12; /* è¿›é˜¶ */
            --tier-color-3: #3498db; /* ç†Ÿç»ƒ */
            --tier-color-4: #2ecc71; /* å“è¶Š */
            --tier-color-5: #9b59b6; /* å¤§å¸ˆ */
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(45deg, #1f264a, #2f3868, #5a4a78, #8b5a8b, #c26b9d);
            background-size: 400% 400%;
            animation: gradientShift 20s ease infinite;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
            color: white;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .floating-particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .particle { position: absolute; width: 4px; height: 4px; background: rgba(255, 255, 255, 0.7); border-radius: 50%; animation: float 8s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0px); opacity: 0.8; } 50% { transform: translateY(-25px); opacity: 0.3; } }

        .game-container {
            background: rgba(10, 15, 40, 0.5); backdrop-filter: blur(25px); border-radius: 25px;
            padding: 40px; box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
            max-width: 800px; width: 100%; border: 2px solid rgba(255, 255, 255, 0.1); position: relative; z-index: 2;
        }
        .game-container::before {
            content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd);
            border-radius: 27px; z-index: -1; animation: borderGlow 4s ease-in-out infinite alternate;
        }
        @keyframes borderGlow { from { opacity: 0.4; transform: scale(1); } to { opacity: 0.8; transform: scale(1.01); } }

        .header { text-align: center; margin-bottom: 30px; }
        .title {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-size: 32px; font-weight: 900; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            animation: titlePulse 2s ease-in-out infinite alternate;
        }
        @keyframes titlePulse { from { transform: scale(1); } to { transform: scale(1.05); } }

        .game-info {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;
            padding: 20px; background: rgba(0,0,0,0.2);
            border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .instruction { font-size: 16px; font-weight: 700; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        .timer {
            font-size: 20px; font-weight: 900; background: linear-gradient(45deg, #ff6b6b, #feca57); background-clip: text;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; min-width: 100px; text-align: right;
        }

        .game-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-bottom: 30px; justify-content: center; }
        .card { width: 100%; aspect-ratio: 1; border: none; border-radius: 15px; font-size: 32px; font-weight: 900; cursor: pointer; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); display: flex; align-items: center; justify-content: center; user-select: none; position: relative; overflow: hidden; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); transform-style: preserve-3d; }
        .card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.4s; transform-style: preserve-3d; }
        .card.flipped .card-inner { transform: rotateY(180deg); }
        .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; border-radius: 15px; }
        .card-front { background: linear-gradient(135deg, #ff9500, #ff6b00); }
        .card-front::after { content: '?'; font-size: 48px; opacity: 0.7; }
        .card-back { background: linear-gradient(135deg, #2ecc71, #27ae60); transform: rotateY(180deg); }
        .card:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5); }
        .card:focus-visible { outline: 2px solid var(--primary-glow); box-shadow: 0 0 15px var(--primary-glow); }
        .card.matched { background: linear-gradient(135deg, #9b59b6, #8e44ad); transform: scale(0.95); cursor: not-allowed; animation: matchPulse 0.6s ease-in-out; opacity: 0.7; }
        .card.matched .card-inner { transform: rotateY(180deg); }
        .card.shake { animation: shake 0.6s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes matchPulse { 0% { transform: scale(0.95); } 50% { transform: scale(1.1); } 100% { transform: scale(0.95); } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        .controls { text-align: center; margin-top: 25px; }
        .btn { background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 15px 30px; border-radius: 50px; font-size: 16px; font-weight: 700; cursor: pointer; margin: 0 10px; transition: all 0.3s ease; box-shadow: 0 8px 16px var(--secondary-glow); }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 12px 24px var(--secondary-glow); }
        .btn:disabled { background: linear-gradient(135deg, #bdc3c7, #95a5a6); cursor: not-allowed; transform: none; box-shadow: 0 4px 8px rgba(189, 195, 199, 0.4); }

        .phase-indicator { text-align: center; font-size: 20px; font-weight: 900; margin-bottom: 20px; padding: 15px; border-radius: 15px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); animation: phaseGlow 2s ease-in-out infinite alternate; }
        @keyframes phaseGlow { from { box-shadow: 0 0 20px rgba(255, 255, 255, 0.2); } to { box-shadow: 0 0 30px rgba(255, 255, 255, 0.4); } }
        .play-phase { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .ready-phase { background: linear-gradient(135deg, #3498db, #2980b9); }
        
        .analysis-report-screen, .history-screen { display: none; text-align: center; animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        /* --- è®¤çŸ¥åˆ†ææŠ¥å‘Š v3.0 Pro æ ·å¼ --- */
        .report-header { margin-bottom: 25px; }
        .report-title { font-size: 28px; margin-bottom: 10px; }
        .profile-title { font-size: 24px; font-weight: 900; color: #f1c40f; text-shadow: 0 0 10px rgba(241, 196, 15, 0.8); }

        .report-container { display: grid; grid-template-columns: 280px 1fr; gap: 30px; text-align: left; }
        .report-left, .report-right { display: flex; flex-direction: column; gap: 20px; }
        
        .radar-chart-container { position: relative; width: 100%; aspect-ratio: 1; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 15px; }
        .radar-chart { width: 100%; height: 100%; }
        .radar-grid { stroke: rgba(255, 255, 255, 0.2); stroke-width: 1; fill: none; }
        .radar-axis { stroke: rgba(255, 255, 255, 0.3); stroke-width: 1; }
        .radar-area { fill: rgba(78, 205, 196, 0.4); stroke: #4ecdc4; stroke-width: 2; }
        .radar-point { fill: #4ecdc4; stroke: white; stroke-width: 2px; }
        .radar-labels { font-size: 11px; fill: white; text-anchor: middle; font-weight: bold; }

        .stat-tiers-container { background: rgba(0,0,0,0.2); padding: 20px; border-radius: 15px; }
        .stat-tier-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .stat-tier-item:last-child { margin-bottom: 0; }
        .stat-tier-label { font-size: 14px; color: rgba(255,255,255,0.8); }
        .stat-tier-value { font-size: 16px; font-weight: 700; padding: 4px 10px; border-radius: 20px; color: white; }
        
        .profile-analysis, .dynamic-analysis { background: rgba(0,0,0,0.2); padding: 20px; border-radius: 15px; }
        .analysis-section-title { font-size: 18px; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        .analysis-text { font-size: 15px; line-height: 1.7; color: rgba(255,255,255,0.9); }
        
        .dynamic-insight { display: flex; align-items: flex-start; gap: 15px; margin-top: 15px; }
        .sparkline-container { width: 120px; height: 40px; background: rgba(0,0,0,0.3); border-radius: 8px; flex-shrink: 0; display: flex; justify-content: center; align-items: center;}
        .sparkline-svg { width: 100%; height: 100%; }
        .sparkline-line { fill: none; stroke: #4ecdc4; stroke-width: 2; }
        .sparkline-fill { fill: rgba(78, 205, 196, 0.2); }
        
        .tooltip { position: fixed; background: #2c3e50; color: white; padding: 10px 15px; border-radius: 8px; font-size: 14px; max-width: 250px; z-index: 10; pointer-events: none; opacity: 0; transform: scale(0.95); transition: opacity 0.2s, transform 0.2s; text-align: left; }
        .tooltip.active { opacity: 1; transform: scale(1); }
        .history-link { display: inline-block; margin-top: 25px; color: #4ecdc4; text-decoration: none; cursor: pointer; font-size: 18px; font-weight: 700; transition: all 0.3s ease; text-shadow: 0 0 10px var(--primary-glow); }
        .history-link:hover { color: #45b7d1; transform: translateY(-2px); }

        /* --- å†å²è¶‹åŠ¿å›¾è¡¨æ ·å¼ --- */
        .chart-container { background: rgba(0,0,0,0.2); padding: 20px; border-radius: 15px; margin-bottom: 25px; }
        .history-chart { width: 100%; height: 250px; }
        .chart-axis-line, .chart-grid-line { stroke: rgba(255,255,255,0.2); stroke-width: 1; }
        .chart-axis-text { fill: rgba(255,255,255,0.6); font-size: 10px; }
        .chart-line { fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; transition: stroke .3s; }
        .chart-point { r: 4; stroke: white; stroke-width: 2px; transition: r .3s; }
        .chart-legend { display: flex; justify-content: center; gap: 20px; margin-top: 15px; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; cursor: pointer; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
        
        .history-list { text-align: left; max-height: 250px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 15px; padding: 0 10px; }
        .history-item { display: flex; justify-content: space-between; padding: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .history-item:last-child { border-bottom: none; }
        
        @media (max-width: 800px) {
            .game-container { padding: 20px; }
            .title { font-size: 24px; }
            .report-container { grid-template-columns: 1fr; }
            .card { font-size: 28px; grid-column: span 1; }
             .game-grid { grid-template-columns: repeat(4, 1fr); }
        }
    </style>
</head>
<body>
    <div class="floating-particles" id="particles"></div>
    <div id="tooltip" class="tooltip"></div>
    <div class="game-container">
        <div id="gameScreen">
            <div class="header">
                <h1 class="title">âœ¨ æ•°å­—é…å¯¹è®°å¿†æŒ‘æˆ˜ âœ¨</h1>
            </div>
            <div class="game-info">
                <div class="instruction">ğŸ¯ å°†0è‡³9çš„æ•°å­—é…å¯¹</div>
                <div class="timer" id="timer" aria-live="polite">0.000</div>
            </div>
            <div class="phase-indicator ready-phase" id="phaseIndicator">ğŸš€ å‡†å¤‡å¼€å§‹æ¸¸æˆ</div>
            <div class="game-grid" id="gameGrid"></div>
            <div class="controls">
                <button class="btn" id="startBtn">ğŸ® å¼€å§‹æ¸¸æˆ</button>
                <button class="btn" id="resetBtn" style="display: none;">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
        </div>

        <div id="analysisReportScreen" class="analysis-report-screen">
            <div class="report-header">
                <h2 class="report-title">æ·±åº¦è®¤çŸ¥å‰–é¢æŠ¥å‘Š</h2>
                <div id="profileTitle" class="profile-title"></div>
            </div>
            <div class="report-container">
                <div class="report-left">
                    <div class="radar-chart-container">
                        <svg id="cognitiveProfileChart" class="radar-chart"></svg>
                    </div>
                    <div id="statTiersContainer" class="stat-tiers-container"></div>
                </div>
                <div class="report-right">
                    <div class="profile-analysis">
                        <h3 class="analysis-section-title">ğŸ“Š ç­–ç•¥çŸ©é˜µè§£è¯»</h3>
                        <div id="profileAnalysisText" class="analysis-text"></div>
                    </div>
                    <div class="dynamic-analysis">
                        <h3 class="analysis-section-title">ğŸ’¡ åŠ¨æ€è¡¨ç°æ´å¯Ÿ</h3>
                        <div id="dynamicAnalysisContainer"></div>
                    </div>
                </div>
            </div>
            <div class="history-link" id="showHistoryLink">ğŸ“ˆ æŸ¥çœ‹å†å²è¶‹åŠ¿</div>
            <div class="controls">
                <button class="btn" id="playAgainBtn">ğŸ”„ å†ç©ä¸€æ¬¡</button>
            </div>
        </div>

        <div id="historyScreen" class="history-screen">
            <h2 style="font-size: 28px; margin-bottom: 20px;">ğŸ“ˆ å†å²è¶‹åŠ¿å›¾</h2>
            <div class="chart-container">
                <svg id="historyChart" class="history-chart"></svg>
                <div id="historyChartLegend" class="chart-legend"></div>
            </div>
            <div class="history-list" id="historyList"></div>
            <div class="controls">
                <button class="btn" id="backToReportBtn">â†©ï¸ è¿”å›æŠ¥å‘Š</button>
                <button class="btn" id="clearHistoryBtn">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
            </div>
        </div>
    </div>

    <script>
        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            TOTAL_PAIRS: 10,
            FLIP_BACK_DELAY: 800,
            STORAGE_KEY: 'gameHistory_v3.1_pro',
            PARTICLE_COUNT: 50,
            MAX_HISTORY_ITEMS: 15,
        };

        const PERFORMANCE_TIERS = {
            tiers: ['æ–°æ‰‹', 'è¿›é˜¶', 'ç†Ÿç»ƒ', 'å“è¶Š', 'å¤§å¸ˆ'],
            colors: ['--tier-color-1', '--tier-color-2', '--tier-color-3', '--tier-color-4', '--tier-color-5']
        };

        const game = {
            // --- UI å…ƒç´ æ˜ å°„ ---
            ui: {
                gameScreen: document.getElementById('gameScreen'),
                analysisReportScreen: document.getElementById('analysisReportScreen'),
                historyScreen: document.getElementById('historyScreen'),
                startBtn: document.getElementById('startBtn'),
                resetBtn: document.getElementById('resetBtn'),
                playAgainBtn: document.getElementById('playAgainBtn'),
                showHistoryLink: document.getElementById('showHistoryLink'),
                backToReportBtn: document.getElementById('backToReportBtn'),
                clearHistoryBtn: document.getElementById('clearHistoryBtn'),
                gameGrid: document.getElementById('gameGrid'),
                timerEl: document.getElementById('timer'),
                phaseIndicator: document.getElementById('phaseIndicator'),
                particles: document.getElementById('particles'),
                tooltip: document.getElementById('tooltip'),
                // æŠ¥å‘ŠUI
                profileTitle: document.getElementById('profileTitle'),
                cognitiveProfileChart: document.getElementById('cognitiveProfileChart'),
                statTiersContainer: document.getElementById('statTiersContainer'),
                profileAnalysisText: document.getElementById('profileAnalysisText'),
                dynamicAnalysisContainer: document.getElementById('dynamicAnalysisContainer'),
                // å†å²UI
                historyChart: document.getElementById('historyChart'),
                historyChartLegend: document.getElementById('historyChartLegend'),
                historyList: document.getElementById('historyList'),
            },

            // --- æ¸¸æˆçŠ¶æ€ ---
            state: {},

            // --- å†å²è®°å½• ---
            history: (() => {
                try {
                    return JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEY) || '[]');
                } catch (e) {
                    console.error("æ— æ³•è§£æå†å²è®°å½•:", e);
                    return [];
                }
            })(),

            // --- æ ¸å¿ƒæ–¹æ³• ---
            methods: {
                init() {
                    this.createParticles();
                    this.attachEventListeners();
                    this.resetGame();
                },

                // --- æ¸¸æˆæµç¨‹æ§åˆ¶ ---
                resetGameState() {
                    cancelAnimationFrame(game.state.animationFrameId);
                    game.state = {
                        phase: 'ready',
                        startTime: null,
                        animationFrameId: null,
                        flippedCards: [],
                        matchedPairs: 0,
                        isChecking: false,
                        totalPairs: CONFIG.TOTAL_PAIRS,
                        turnHistory: [],
                        turnStartTime: null,
                    };
                },

                startGame() {
                    game.ui.startBtn.disabled = true;
                    this.resetGameState();
                    game.state.phase = 'play';
                    game.state.startTime = Date.now();
                    this.createGameGrid();
                    this.updatePhaseIndicator('ğŸ® é…å¯¹é˜¶æ®µ - æ‰¾å‡ºæ‰€æœ‰ç›¸åŒæ•°å­—ï¼', 'play-phase');
                    game.ui.startBtn.style.display = 'none';
                    game.ui.resetBtn.style.display = 'inline-block';
                    game.ui.resetBtn.disabled = false;
                    this.startTimer();
                },
                
                finishGame() {
                    game.state.phase = 'finished';
                    const totalTime = (Date.now() - game.state.startTime) / 1000;
                    const analysisData = this.analyzePerformance(game.state.turnHistory);

                    const result = {
                        date: new Date().toLocaleString('zh-CN', { dateStyle: 'short', timeStyle: 'short' }),
                        time: totalTime.toFixed(3),
                        profileName: analysisData.profile.name,
                        analysisData,
                    };
                    
                    game.history.unshift(result);
                    if (game.history.length > CONFIG.MAX_HISTORY_ITEMS) game.history.pop();
                    localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(game.history));
                    
                    this.renderAnalysisReport(result);
                },

                resetGame() {
                    this.resetGameState();
                    this.switchScreen('gameScreen');
                    game.ui.startBtn.style.display = 'inline-block';
                    game.ui.startBtn.disabled = false;
                    game.ui.resetBtn.style.display = 'none';
                    game.ui.gameGrid.innerHTML = '';
                    game.ui.timerEl.textContent = '0.000';
                    this.updatePhaseIndicator('ğŸš€ å‡†å¤‡å¼€å§‹æ¸¸æˆ', 'ready-phase');
                },
                
                // --- æ¸¸æˆäº¤äº’é€»è¾‘ ---
                createGameGrid() {
                    game.ui.gameGrid.innerHTML = '';
                    const fragment = document.createDocumentFragment();
                    const cardNumbers = Array.from({ length: CONFIG.TOTAL_PAIRS }, (_, i) => i);
                    const shuffledCards = [...cardNumbers, ...cardNumbers].sort(() => Math.random() - 0.5);
                    
                    shuffledCards.forEach(number => {
                        const card = document.createElement('div');
                        card.className = 'card';
                        card.dataset.number = number;
                        card.setAttribute('role', 'button');
                        card.setAttribute('tabindex', '0');
                        card.setAttribute('aria-label', 'æœªç¿»å¼€çš„å¡ç‰Œ');
                        card.innerHTML = `<div class="card-inner"><div class="card-face card-front"></div><div class="card-face card-back">${number}</div></div>`;
                        card.addEventListener('click', () => this.handleCardClick(card));
                        card.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') this.handleCardClick(card);
                        });
                        fragment.appendChild(card);
                    });
                    game.ui.gameGrid.appendChild(fragment);
                },

                handleCardClick(card) {
                    const { phase, isChecking, flippedCards } = game.state;
                    if (phase !== 'play' || isChecking || card.classList.contains('flipped')) return;
                    
                    if (flippedCards.length === 0) game.state.turnStartTime = Date.now();

                    card.classList.add('flipped');
                    card.setAttribute('aria-label', `å¡ç‰Œ ${card.dataset.number}`);
                    flippedCards.push(card);
                    
                    if (flippedCards.length === 2) {
                        game.state.isChecking = true;
                        this.checkMatch();
                    }
                },

                checkMatch() {
                    const [card1, card2] = game.state.flippedCards;
                    const isMatch = card1.dataset.number === card2.dataset.number;
                    const turnDuration = (Date.now() - game.state.turnStartTime) / 1000;

                    game.state.turnHistory.push({ isMatch, duration: turnDuration });

                    setTimeout(() => {
                        if (isMatch) {
                            card1.classList.add('matched');
                            card2.classList.add('matched');
                            card1.setAttribute('aria-label', `å·²åŒ¹é…çš„å¡ç‰Œ ${card1.dataset.number}`);
                            card2.setAttribute('aria-label', `å·²åŒ¹é…çš„å¡ç‰Œ ${card2.dataset.number}`);
                            game.state.matchedPairs++;
                            if (game.state.matchedPairs === game.state.totalPairs) this.finishGame();
                        } else {
                            card1.classList.add('shake');
                            card2.classList.add('shake');
                            setTimeout(() => {
                                card1.classList.remove('flipped', 'shake');
                                card2.classList.remove('flipped', 'shake');
                                card1.setAttribute('aria-label', 'æœªç¿»å¼€çš„å¡ç‰Œ');
                                card2.setAttribute('aria-label', 'æœªç¿»å¼€çš„å¡ç‰Œ');
                            }, 500);
                        }
                        game.state.flippedCards = [];
                        game.state.isChecking = false;
                    }, CONFIG.FLIP_BACK_DELAY);
                },

                // --- æ·±åº¦åˆ†ææ¨¡å— ---
                analyzePerformance(turnHistory) {
                    const metrics = this.calculatePrimaryMetrics(turnHistory);
                    const profile = this.determineCognitiveProfile(metrics);
                    const dynamics = this.analyzeInGameDynamics(turnHistory);
                    return { ...metrics, ...profile, ...dynamics };
                },

                calculatePrimaryMetrics(turnHistory) {
                    const totalTurns = turnHistory.length;
                    if (totalTurns === 0) return { score: 0, memoryEfficiency: 0, speedScore: 0, consistencyScore: 0, mistakes: 0, turnDurations: [] };
                    const mistakes = turnHistory.filter(t => !t.isMatch).length;
                    const turnDurations = turnHistory.map(t => t.duration);
                    const avgReactionTime = turnDurations.reduce((a, b) => a + b, 0) / totalTurns;
                    const stdDev = Math.sqrt(turnDurations.map(x => Math.pow(x - avgReactionTime, 2)).reduce((a, b) => a + b, 0) / totalTurns);
                    const memoryEfficiency = (CONFIG.TOTAL_PAIRS / totalTurns) * 100;
                    const speedScore = Math.max(0, Math.min(100, 100 - (avgReactionTime - 0.5) * 40));
                    const consistencyScore = Math.max(0, Math.min(100, 100 - stdDev * 100));
                    const score = Math.round((memoryEfficiency * 0.5) + (speedScore * 0.25) + (consistencyScore * 0.25));
                    return { score, memoryEfficiency, speedScore, consistencyScore, mistakes, turnDurations };
                },

                determineCognitiveProfile(metrics) {
                    const { memoryEfficiency, speedScore } = metrics;
                    let profile;
                    if (speedScore >= 60) {
                        if (memoryEfficiency >= 60) {
                            profile = { name: 'æ•é”æˆ˜ç•¥å®¶', text: 'æ‚¨èƒ½ä»¥æå¿«çš„é€Ÿåº¦ç²¾å‡†å†³ç­–ï¼Œå±•ç°å‡ºå“è¶Šçš„å·¥ä½œè®°å¿†å’Œé«˜æ•ˆçš„è®¤çŸ¥å¤„ç†èƒ½åŠ›ã€‚æ‚¨æ˜¯å¤©ç”Ÿçš„å¿«é€Ÿé—®é¢˜è§£å†³è€…ã€‚' };
                        } else {
                            profile = { name: 'ç›´è§‰æ¢ç´¢è€…', text: 'æ‚¨çš„ååº”é€Ÿåº¦æå¿«ï¼Œå€¾å‘äºé€šè¿‡å¿«é€Ÿå°è¯•æ¥å¯»æ‰¾ç­”æ¡ˆã€‚è¿™ç§é£æ ¼åœ¨æ¢ç´¢æœªçŸ¥æ—¶éå¸¸æœ‰æ•ˆï¼Œä½†æ³¨æ„æ§åˆ¶å¤±è¯¯ç‡èƒ½è®©æ‚¨æ›´ä¸Šä¸€å±‚æ¥¼ã€‚' };
                        }
                    } else {
                        if (memoryEfficiency >= 60) {
                            profile = { name: 'ç¼œå¯†è®¡åˆ’è€…', text: 'æ‚¨è¡ŒåŠ¨å‰æ·±æ€ç†Ÿè™‘ï¼Œæ¯ä¸€æ­¥éƒ½åŠ›æ±‚ç²¾å‡†ã€‚è¿™ç§æ²‰ç¨³ã€é›¶å¤±è¯¯çš„é£æ ¼ä½“ç°äº†å¼ºå¤§çš„è§„åˆ’èƒ½åŠ›å’Œè®°å¿†å‡†ç¡®æ€§ï¼Œæ˜¯å¯é æ€§çš„å…¸èŒƒã€‚' };
                        } else {
                            profile = { name: 'æ²‰ç¨³å­¦ä¹ è€…', text: 'æ‚¨åœ¨è°¨æ…åœ°æ¢ç´¢å’Œå­¦ä¹ è§„åˆ™ã€‚è™½ç„¶é€Ÿåº¦å’Œæ•ˆç‡æœ‰å¾…æå‡ï¼Œä½†è¿™ç§ç¨³å¥çš„æ­¥ä¼æ˜¯æ„å»ºå¼ºå¤§è®¤çŸ¥èƒ½åŠ›çš„åŸºç¡€ã€‚å¤šåŠ ç»ƒä¹ ï¼Œæ‚¨å°†å¾ˆå¿«è¿›æ­¥ï¼' };
                        }
                    }
                    return { profile };
                },
                
                analyzeInGameDynamics(turnHistory) {
                    if (turnHistory.length < CONFIG.TOTAL_PAIRS) return { trend: {text:'æ•°æ®ä¸è¶³'}, errorPattern: {text:'æ•°æ®ä¸è¶³'} };
                    const turns = turnHistory.length;
                    const firstHalfTurns = turnHistory.slice(0, Math.floor(turns / 2));
                    const secondHalfTurns = turnHistory.slice(Math.floor(turns / 2));
                    const firstHalfAvgTime = firstHalfTurns.length ? firstHalfTurns.reduce((sum, t) => sum + t.duration, 0) / firstHalfTurns.length : 0;
                    const secondHalfAvgTime = secondHalfTurns.length ? secondHalfTurns.reduce((sum, t) => sum + t.duration, 0) / secondHalfTurns.length : 0;
                    let trend;
                    if (secondHalfAvgTime < firstHalfAvgTime * 0.9) {
                        trend = { text: 'æ‚¨è¡¨ç°å‡ºæ˜¾è‘—çš„<strong style="color: var(--tier-color-4)">å­¦ä¹ æ•ˆåº”</strong>ï¼Œè¶Šç©è¶Šå¿«ï¼Œè¡¨æ˜æ‚¨èƒ½è¿…é€Ÿé€‚åº”æŒ‘æˆ˜å¹¶ä¼˜åŒ–ç­–ç•¥ã€‚' };
                    } else if (firstHalfAvgTime < secondHalfAvgTime * 0.9) {
                        trend = { text: 'æ‚¨çš„åæœŸååº”æ—¶é—´æœ‰æ‰€å¢åŠ ï¼Œå¯èƒ½è¡¨æ˜åœ¨æ¸¸æˆåæœŸå‡ºç°äº†<strong style="color: var(--tier-color-2)">è®¤çŸ¥ç–²åŠ³</strong>ã€‚ä¿æŒä¸“æ³¨æ˜¯å…³é”®ã€‚' };
                    } else {
                        trend = { text: 'æ‚¨åœ¨æ•´åœºæ¸¸æˆä¸­éƒ½ä¿æŒäº†<strong style="color: var(--tier-color-3)">ç¨³å®šçš„è¡¨ç°èŠ‚å¥</strong>ï¼Œå±•ç°äº†å‡ºè‰²çš„ä¸“æ³¨åŠ›è€åŠ›ã€‚' };
                    }
                    const mistakes = turnHistory.map((t, i) => ({...t, index: i})).filter(t => !t.isMatch);
                    let errorPattern;
                    if (mistakes.length > 1) {
                        const avgErrorIndex = mistakes.reduce((sum, t) => sum + t.index, 0) / mistakes.length;
                        if (avgErrorIndex < turns / 3) {
                            errorPattern = { text: 'å¤±è¯¯ä¸»è¦é›†ä¸­åœ¨<strong style="color: var(--tier-color-2)">æ¸¸æˆå‰æœŸ</strong>ï¼Œè¿™å¾ˆæ­£å¸¸ï¼Œæ˜¯ç†Ÿæ‚‰å¸ƒå±€çš„æ¢ç´¢é˜¶æ®µã€‚' };
                        } else if (avgErrorIndex > turns * 2 / 3) {
                            errorPattern = { text: 'å¤±è¯¯å¤šå‘ç”Ÿåœ¨<strong style="color: var(--tier-color-4)">æ¸¸æˆåæœŸ</strong>ï¼Œå¯èƒ½æ˜¯è®°å¿†è´Ÿè·è¿‡å¤§å¯¼è‡´ã€‚åˆ†å—è®°å¿†æˆ–èƒ½æ”¹å–„ã€‚' };
                        } else {
                            errorPattern = { text: 'å¤±è¯¯<strong style="color: var(--tier-color-3)">å‡åŒ€åˆ†å¸ƒ</strong>ï¼Œè¡¨æ˜æ²¡æœ‰ç‰¹å®šçš„è–„å¼±é˜¶æ®µï¼Œæ•´ä½“è¡¨ç°å‡è¡¡ã€‚' };
                        }
                    } else {
                        errorPattern = { text: `æ‚¨çš„å¤±è¯¯ä»…æœ‰ ${mistakes.length} æ¬¡ï¼Œè¡¨ç°å‡º<strong style="color: var(--tier-color-5)">é«˜åº¦çš„å‡†ç¡®æ€§</strong>ã€‚` };
                    }
                    return { trend, errorPattern };
                },

                getPerformanceTier(score) {
                    const tierIndex = Math.min(Math.floor(score / 20), 4);
                    return {
                        name: PERFORMANCE_TIERS.tiers[tierIndex],
                        color: `var(${PERFORMANCE_TIERS.colors[tierIndex]})`
                    };
                },

                // --- æŠ¥å‘Šä¸å›¾è¡¨æ¸²æŸ“ ---
                renderAnalysisReport(result) {
                    this.switchScreen('analysisReportScreen');
                    const { analysisData } = result;
                    game.ui.profileTitle.textContent = `æ‚¨çš„ç­–ç•¥è±¡é™ï¼š${analysisData.profile.name}`;
                    const radarData = { "è®°å¿†æ•ˆç‡": analysisData.memoryEfficiency, "å†³ç­–é€Ÿåº¦": analysisData.speedScore, "è¡¨ç°ä¸€è‡´æ€§": analysisData.consistencyScore };
                    this.createRadarChart(game.ui.cognitiveProfileChart, radarData);
                    const tiersContainer = game.ui.statTiersContainer;
                    tiersContainer.innerHTML = '';
                    const metricsToDisplay = { 'ç»¼åˆå¾—åˆ†': analysisData.score, 'è®°å¿†æ•ˆç‡': analysisData.memoryEfficiency, 'å†³ç­–é€Ÿåº¦': analysisData.speedScore, 'è¡¨ç°ä¸€è‡´æ€§': analysisData.consistencyScore };
                    for (const label in metricsToDisplay) {
                        const score = metricsToDisplay[label];
                        const tier = this.getPerformanceTier(score);
                        tiersContainer.innerHTML += `<div class="stat-tier-item"><span class="stat-tier-label">${label}</span><span class="stat-tier-value" style="background-color: ${tier.color}">${tier.name} (${Math.round(score)})</span></div>`;
                    }
                    game.ui.profileAnalysisText.innerHTML = analysisData.profile.text;
                    game.ui.dynamicAnalysisContainer.innerHTML = `<div class="dynamic-insight"><div class="sparkline-container" id="sparklineContainer"></div><div class="analysis-text">${analysisData.trend.text}</div></div><div class="dynamic-insight" style="align-items: center;"><div class="analysis-text" style="width: 100%">${analysisData.errorPattern.text}</div></div>`;
                    this.createSparkline(document.getElementById('sparklineContainer'), analysisData.turnDurations);
                },
                
                createRadarChart(svg, data) {
                    svg.innerHTML = ''; const size = svg.clientWidth; const center = size / 2; const radius = size * 0.38; const labels = Object.keys(data); const numAxes = labels.length;
                    for (let i = 1; i <= 4; i++) { const r = radius * (i / 4); const points = labels.map((_, j) => { const angle = (j / numAxes) * 2 * Math.PI - Math.PI / 2; return `${center + r * Math.cos(angle)},${center + r * Math.sin(angle)}`; }).join(' '); svg.appendChild(this.createSVGElement('polygon', { points, class: 'radar-grid' })); }
                    labels.forEach((label, i) => { const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2; svg.appendChild(this.createSVGElement('line', { x1: center, y1: center, x2: center + radius * Math.cos(angle), y2: center + radius * Math.sin(angle), class: 'radar-axis' })); const text = this.createSVGElement('text', { x: center + (radius + 20) * Math.cos(angle), y: center + (radius + 20) * Math.sin(angle), class: 'radar-labels' }); text.textContent = label; svg.appendChild(text); });
                    const dataPoints = labels.map((label, i) => { const value = (data[label] || 0) / 100; const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2; const p = { x: center + radius * value * Math.cos(angle), y: center + radius * value * Math.sin(angle) }; svg.appendChild(this.createSVGElement('circle', { cx: p.x, cy: p.y, r: 4, class: 'radar-point' })); return `${p.x},${p.y}`; }).join(' ');
                    const area = this.createSVGElement('polygon', { points: dataPoints, class: 'radar-area' }); area.innerHTML = `<animate attributeName="points" from="${new Array(numAxes).fill(`${center},${center}`).join(' ')}" to="${dataPoints}" dur="0.7s" fill="freeze" calcMode="spline" keySplines="0.25 0.1 0.25 1" />`; svg.appendChild(area);
                },

                createSparkline(container, data) {
                    if (!data || data.length < 2) { container.innerHTML = `<span style="font-size:10px; color: #aaa;">æ•°æ®ä¸è¶³</span>`; return; }
                    const svg = this.createSVGElement('svg', { class: 'sparkline-svg', viewBox: `0 0 120 40` }); const maxVal = Math.max(...data); const minVal = Math.min(...data); const range = maxVal - minVal === 0 ? 1 : maxVal - minVal;
                    const points = data.map((d, i) => { const x = (i / (data.length - 1)) * 120; const y = 38 - ((d - minVal) / range) * 36; return `${x},${y}`; }).join(' ');
                    const fillPoints = `0,40 ${points} 120,40`;
                    svg.innerHTML = `<polygon class="sparkline-fill" points="${fillPoints}" /><polyline class="sparkline-line" points="${points}" />`;
                    container.innerHTML = ''; container.appendChild(svg);
                },

                renderHistoryChart(history) {
                    const svg = game.ui.historyChart; svg.innerHTML = ''; const legend = game.ui.historyChartLegend; legend.innerHTML = ''; if (history.length < 2) { svg.innerHTML = `<text x="50%" y="50%" fill="white" text-anchor="middle">å®Œæˆè‡³å°‘ä¸¤æ¬¡æŒ‘æˆ˜ä»¥ç”Ÿæˆè¶‹åŠ¿å›¾...</text>`; return; }
                    const data = history.slice(0, CONFIG.MAX_HISTORY_ITEMS).reverse(); const colors = { score: '#4ecdc4', mei: '#e67e22', speed: '#9b59b6' }; const dataMap = { score: 'score', mei: 'memoryEfficiency', speed: 'speedScore' }; const labels = { score: 'ç»¼åˆå¾—åˆ†', mei: 'è®°å¿†æ•ˆç‡', speed: 'å†³ç­–é€Ÿåº¦' };
                    const { width, height } = svg.getBoundingClientRect(); const padding = { top: 20, right: 20, bottom: 30, left: 30 }; const xScale = (i) => padding.left + (width - padding.left - padding.right) * (i / (data.length - 1)); const yScale = (val) => height - padding.bottom - (height - padding.top - padding.bottom) * (val / 100);
                    const yAxis = this.createSVGElement('g'); [0, 25, 50, 75, 100].forEach(val => { const y = yScale(val); yAxis.appendChild(this.createSVGElement('line', { x1: padding.left, y1: y, x2: width - padding.right, y2: y, class: 'chart-grid-line' })); const text = this.createSVGElement('text', { x: padding.left - 5, y: y + 4, class: 'chart-axis-text', 'text-anchor': 'end'}); text.textContent = val; yAxis.appendChild(text); }); svg.appendChild(yAxis);
                    Object.keys(labels).forEach(key => { const dataKey = dataMap[key]; const linePath = data.map((d, i) => `${i === 0 ? 'M' : 'L'} ${xScale(i)} ${yScale(d.analysisData[dataKey])}`).join(' '); const line = this.createSVGElement('path', { d: linePath, class: `chart-line`, style: `stroke: ${colors[key]}` }); svg.appendChild(line); data.forEach((d, i) => { const point = this.createSVGElement('circle', { cx: xScale(i), cy: yScale(d.analysisData[dataKey]), class: `chart-point`, style: `fill: ${colors[key]}` }); point.innerHTML = `<title>ç¬¬${game.history.length - data.length + i + 1}æ¬¡ - ${labels[key]}: ${Math.round(d.analysisData[dataKey])}</title>`; svg.appendChild(point); }); const item = document.createElement('div'); item.className = 'legend-item'; item.innerHTML = `<div class="legend-color" style="background-color: ${colors[key]}"></div><span>${labels[key]}</span>`; legend.appendChild(item); });
                },

                // --- é¡µé¢å¯¼èˆªä¸å†å² ---
                showHistory() {
                    this.switchScreen('historyScreen');
                    game.ui.historyList.innerHTML = game.history.length === 0 
                        ? '<div style="text-align: center; color: rgba(255,255,255,0.7);">ğŸ” æš‚æ— å†å²è®°å½•</div>'
                        : game.history.map(r => `
                            <div class="history-item">
                                <div><div style="font-weight: 700;">${r.date}</div><div style="font-size: 14px; color: rgba(255,255,255,0.7); margin-top: 5px;">ç”¨æ—¶: ${r.time}s | ${r.profileName}</div></div>
                                <div style="font-weight: 900; font-size: 18px;">${r.analysisData.score}/100</div>
                            </div>`).join('');
                    this.renderHistoryChart(game.history);
                },

                backToReport() {
                    this.switchScreen('analysisReportScreen');
                },

                clearHistory() {
                    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ')) {
                        game.history = [];
                        localStorage.removeItem(CONFIG.STORAGE_KEY);
                        this.showHistory();
                    }
                },
                
                // --- é€šç”¨å·¥å…·æ–¹æ³• ---
                createParticles() {
                    if (game.ui.particles.children.length > 0) return;
                    const fragment = document.createDocumentFragment();
                    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                        const p = document.createElement('div'); p.className = 'particle'; p.style.left = `${Math.random() * 100}%`; p.style.top = `${Math.random() * 100}%`; p.style.animationDelay = `${Math.random() * 8}s`; p.style.animationDuration = `${Math.random() * 5 + 5}s`; fragment.appendChild(p);
                    }
                    game.ui.particles.appendChild(fragment);
                },
                
                switchScreen(screenId) {
                    ['gameScreen', 'analysisReportScreen', 'historyScreen'].forEach(id => {
                        game.ui[id].style.display = (id === screenId) ? 'block' : 'none';
                    });
                },

                updatePhaseIndicator(text, phaseClass) {
                    game.ui.phaseIndicator.textContent = text;
                    game.ui.phaseIndicator.className = 'phase-indicator';
                    if (phaseClass) game.ui.phaseIndicator.classList.add(phaseClass);
                },

                startTimer() {
                    const update = () => {
                        if (game.state.phase !== 'play') return;
                        const elapsedTime = (Date.now() - game.state.startTime) / 1000;
                        game.ui.timerEl.textContent = elapsedTime.toFixed(3);
                        game.state.animationFrameId = requestAnimationFrame(update);
                    };
                    game.state.animationFrameId = requestAnimationFrame(update);
                },

                createSVGElement: (tag, attrs) => {
                    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                    for (const key in attrs) el.setAttribute(key, attrs[key]);
                    return el;
                },

                attachEventListeners() {
                    game.ui.startBtn.addEventListener('click', () => this.startGame());
                    game.ui.resetBtn.addEventListener('click', () => this.resetGame());
                    game.ui.playAgainBtn.addEventListener('click', () => this.resetGame());
                    game.ui.showHistoryLink.addEventListener('click', () => this.showHistory());
                    game.ui.backToReportBtn.addEventListener('click', () => this.backToReport());
                    game.ui.clearHistoryBtn.addEventListener('click', () => this.clearHistory());
                    document.addEventListener('mouseover', e => { if (e.target.matches('.info-icon')) { const tooltip = game.ui.tooltip; tooltip.textContent = e.target.dataset.tooltip; tooltip.classList.add('active'); const rect = e.target.getBoundingClientRect(); tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`; tooltip.style.top = `${rect.top - tooltip.offsetHeight - 8}px`; } });
                    document.addEventListener('mouseout', e => { if (e.target.matches('.info-icon')) { game.ui.tooltip.classList.remove('active'); } });
                }
            }
        };

        // --- å¯åŠ¨æ¸¸æˆ ---
        game.methods.init();
    </script>
</body>
</html>
