<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>认知反应挑战 G1.6</title>
  <style>
    /* reset */
    * { margin:0; padding:0; box-sizing:border-box; }
    html { scroll-behavior: smooth; }
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100dvh;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c, #4facfe, #00f2fe);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      -webkit-tap-highlight-color: transparent;
      color: white;
    }
    @keyframes gradientShift { 0%, 100% { background-position: 0% 50%; } 25% { background-position: 100% 50%; } 50% { background-position: 100% 100%; } 75% { background-position: 0% 100%; } }

    .floating-particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .particle { position: absolute; width: 6px; height: 6px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; animation: float 8s ease-in-out infinite; }
    @keyframes float { 0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 1; } 50% { transform: translateY(-25px) rotate(180deg); opacity: 0.4; } }

    .game-container {
      position: relative; z-index: 2;
      transition: opacity 0.4s cubic-bezier(0.22, 0.61, 0.36, 1), transform 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
      margin: 20px 0;
    }
    .game-container.hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.95) translateY(10px);
      display: none !important; /* Use important to ensure it's hidden */
    }
    .game-panel {
        background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 25px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        border: 2px solid rgba(255,255,255,0.1);
    }
    .game-panel::before {
      content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd);
      border-radius: 27px; z-index: -1; animation: borderGlow 3s ease-in-out infinite alternate;
    }
    @keyframes borderGlow { 0% { opacity: 0.5; transform: scale(1); } 100% { opacity: 1; transform: scale(1.02); } }

    .control-panel {
      padding: 30px;
      display:flex; gap: 18px; align-items:center; flex-direction: column;
      width: 90vw; max-width: 420px;
    }
    .control-panel h2 { font-size: 24px; font-weight: 700; margin-bottom: 10px; }
    .control-panel .form-group { display: flex; align-items: center; gap: 10px; width: 100%; justify-content: space-between; }
    .control-panel label { font-weight: 600; font-size: 16px; }
    .control-panel select,
    .control-panel input[type="number"]{
      padding:10px 14px; border: 1px solid rgba(255,255,255,0.1); border-radius:10px;
      width:160px; font-size:16px; text-align:center; background:rgba(0,0,0,0.1); color: white;
      transition: all 0.25s ease;
    }
    .control-panel select:focus,
    .control-panel input[type="number"]:focus {
      outline: none; border-color: #879aff; box-shadow: 0 0 0 4px rgba(135, 154, 255, 0.3);
    }
    .control-panel button{
      margin-top: 15px; padding:14px 35px;
      background: linear-gradient(45deg,#ff6b6b,#f0932b);
      color:white; border:none; border-radius:30px; font-size:18px; font-weight:bold;
      cursor:pointer; transition: all .2s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow:0 5px 20px rgba(238,90,36,0.3);
    }
    .control-panel button:hover{ transform: translateY(-5px) scale(1.05); box-shadow:0 10px 30px rgba(238,90,36,0.4); }

    #gameScreen {
      position: fixed; inset:0;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: 20px 0;
    }
    .timer-container { width: 100%; padding: 15px; position: absolute; top: 0; z-index: 120; }
    .timer-bar { width: 95%; max-width: 600px; margin: 0 auto; height: 8px; background-color: rgba(255,255,255,0.25); border-radius: 4px; overflow: hidden; }
    .timer-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #84fab0 0%, #8fd3f4 100%); border-radius: 4px; }
    .game-area { width: 100%; flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5vh; padding: 20px; min-height: 250px; }
    
    .color-word{
        font-size: clamp(80px, 28vmin, 200px);
        font-weight:bold; user-select:none;
        opacity: 0;
    }
    .color-word.anim-enter { animation: word-enter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    @keyframes word-enter { from { transform: scale(0.6) translateY(-20px) rotate(-5deg); opacity: 0; } to { transform: scale(1) translateY(0) rotate(0deg); opacity: 1; } }
    .choice-container { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; padding: 0 10px; }
    .choice-btn {
        padding: 14px 30px; font-size: 20px; font-weight: bold; color: #333; background: rgba(255, 255, 255, 0.98);
        border: none; border-radius: 14px; cursor: pointer;
        box-shadow: 0 5px 25px rgba(0,0,0,0.1); opacity: 0; transform: translateY(30px);
        transition: all 0.2s cubic-bezier(0.22, 0.61, 0.36, 1);
    }
    .choice-btn.anim-enter { animation: button-enter 0.5s cubic-bezier(0.22, 0.61, 0.36, 1) forwards; }
    @keyframes button-enter { to { opacity: 1; transform: translateY(0); } }
    .choice-btn:hover { transform: translateY(-6px) scale(1.04); box-shadow: 0 10px 35px rgba(0,0,0,0.15); }

    #stopBtn {
        position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.2);
        backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); color: white; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; cursor: pointer; z-index: 130; transition: all 0.2s ease;
    }
    #stopBtn:hover { background: rgba(0,0,0,0.4); transform: scale(1.05); }
    .progress-container { flex-shrink: 0; padding-bottom: 20px; }
    .progress-wrapper { background: rgba(0,0,0,0.22); padding: 10px 20px; border-radius:15px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); text-align: center; user-select:none; position: relative; }
    #scoreDisplay.anim-update { animation: score-update 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
    @keyframes score-update { 50% { transform: scale(1.25); } }
    .progress-bar{ width:320px; height:8px; background: rgba(255,255,255,0.2); border-radius:4px; overflow:hidden; }
    .progress-fill{ height:100%; width:0%; border-radius:4px; background: #fff; transition: width .4s cubic-bezier(0.22, 0.61, 0.36, 1); }
    .score-popup { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); font-size: 18px; font-weight: bold; color: #2ed573; animation: score-popup-anim 0.8s ease-out forwards; pointer-events: none; }
    @keyframes score-popup-anim { from { opacity: 1; transform: translate(-50%, 0); } to { opacity: 0; transform: translate(-50%, -40px); } }

    .completion-message {
      padding:25px; text-align:center;
      min-width:280px; display:flex; flex-direction:column; gap:12px;
    }
    .completion-emoji{ font-size:40px; }
    .score-text { font-size: 18px; }

    /* --- Report Screen Styles (REVISED) --- */
    #analysisReportContainer {
      display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px 0;
    }
    #analysisReport {
      max-width: 860px; width: 90vw; padding: 25px;
      max-height: 85vh; overflow-y: auto; text-align: left;
    }
    .report-header { text-align: center; margin-bottom: 20px; }
    .report-header h3 { font-size: 2rem; font-weight: 900; }
    .report-header p { font-size: 1.1rem; opacity: 0.9; margin-top: 5px; }

    .dashboard-grid { display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 25px; }
    .dashboard-profile { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 15px; }
    .dashboard-profile-title { display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 10px; font-size: 1.1em; color: rgba(255,255,255,0.7); }
    .info-trigger { cursor: pointer; font-style: normal; font-weight: bold; width: 18px; height: 18px; border: 1.5px solid rgba(255,255,255,0.5); border-radius: 50%; display: inline-flex; justify-content: center; align-items: center; font-size: 12px; transition: all 0.2s ease; }
    .info-trigger:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }

    .radar-chart-container { position: relative; width: 100%; max-width: 300px; aspect-ratio: 1; display: flex; align-items: center; justify-content: center; margin: 0 auto; }
    .radar-chart { width: 100%; height: 100%; }
    .radar-grid { stroke: rgba(255,255,255,0.2); stroke-width: 1; fill: none; }
    .radar-axis { stroke: rgba(255,255,255,0.3); stroke-width: 1; }
    .radar-area { fill: rgba(78, 205, 196, 0.4); stroke: #4ecdc4; stroke-width: 2; }
    .radar-point { fill: #4ecdc4; stroke: white; stroke-width: 2px; }
    .radar-labels { font-size: clamp(9px, 2.5vw, 12px); fill: white; text-anchor: middle; }
    .radar-scale-labels { font-size: 10px; fill: rgba(255,255,255,0.5); text-anchor: middle; }

    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; text-align: center; margin-bottom: 20px; }
    .summary-item .value { font-size: 1.8rem; font-weight: bold; color: #879aff; }
    .summary-item .label { font-size: 0.8rem; color: rgba(255,255,255,0.7); }
    
    .insight-box { background: rgba(0,0,0,0.15); padding: 15px; border-radius: 10px; }
    .insight-title { text-align: center; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; }
    #profileTypeName { color: #f1c40f; }
    .insight-content { font-size: 0.9em; line-height: 1.6; }
    .insight-content strong { color: #2ed573; } /* Strength */
    .insight-content em { color: #ff6b6b; font-style: normal; } /* Improvement Area */

    .analysis-details { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 15px; margin-top: 20px; }
    .tabs-nav { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
    .tab-btn { padding: 8px 20px; background: rgba(255,255,255,0.1); border: none; color: white; border-radius: 20px; cursor: pointer; transition: all 0.25s ease; font-size: 15px; }
    .tab-btn:hover { background: rgba(255,255,255,0.2); }
    .tab-btn.active { background: #879aff; font-weight: bold; }
    .tab-pane { display: none; animation: fadeIn 0.5s ease; }
    .tab-pane.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .chart-svg { width: 100%; height: 200px; }
    .chart-axis, .chart-axis-line { stroke: rgba(255,255,255,0.3); stroke-width: 1; }
    .chart-axis-text { fill: rgba(255,255,255,0.6); font-size: 10px; }
    .chart-line{fill:none;stroke:#4ecdc4;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;animation:draw-line 1.5s ease-out forwards}.chart-area{fill:url(#chartGradient);opacity:.5;animation:fade-in 1s ease-out forwards}.chart-point{fill:#f1c40f;stroke:rgba(0,0,0,.5);stroke-width:2;transition:r .3s ease}.chart-point:hover{r:7}.chart-avg-line{stroke:#879aff;stroke-width:1.5;stroke-dasharray:4,4}@keyframes draw-line{from{stroke-dasharray:1000;stroke-dashoffset:1000}to{stroke-dasharray:1000;stroke-dashoffset:0}}@keyframes fade-in{from{opacity:0}to{opacity:.5}}
    
    .records-list-container { max-height: 300px; overflow-y: auto; padding-right: 5px; }
    .record-item { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 15px; padding: 12px 10px; border-bottom: 1px solid rgba(255,255,255,0.1); transition: all 0.3s ease; }
    .record-item:last-child { border-bottom: none; }
    .record-item:hover { background: rgba(255, 255, 255, 0.05); transform: translateX(5px); }
    .record-item.is-pb { border-left: 4px solid #f1c40f; padding-left: 6px; }
    .record-details-main { font-size: 0.9em; }
    .record-details-sub { font-size: 0.8em; opacity: 0.7; display: flex; gap: 10px; margin-top: 4px; flex-wrap: wrap; }
    .record-stats { text-align: right; font-weight: bold; font-size: 1.1em; color: #f1c40f; }
    .record-item:not(.is-pb) .record-stats { color: white; }

    #playAgainBtn {
      margin: 25px auto 0; padding: 14px 35px;
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      box-shadow: 0 5px 20px rgba(46, 213, 115, 0.3); color: white; border: none; font-weight: bold; font-size: 18px; border-radius: 30px;
      cursor: pointer; transition: all .2s cubic-bezier(0.34, 1.56, 0.64, 1); display: block;
    }
    #playAgainBtn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 10px 30px rgba(46, 213, 115, 0.4); }
    
    .color-word.correct-feedback { animation: bounce-correct 0.6s ease; }
    .color-word.incorrect-feedback { animation: shake-horizontal 0.5s cubic-bezier(.36,.07,.19,.97); }
    @keyframes bounce-correct { 0%, 100% { transform: translateY(0); } 20% { transform: translateY(-20px); } 50% { transform: translateY(5px); } 80% { transform: translateY(-10px); } }
    @keyframes shake-horizontal { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    
    #feedbackFlash { position: fixed; inset: 0; z-index: 210; opacity: 0; pointer-events: none; transition: opacity 0.4s ease; }
    #feedbackFlash.correct-flash { background: radial-gradient(circle, rgba(46, 213, 115, 0.4) 0%, rgba(46, 213, 115, 0.1) 40%, rgba(46, 213, 115, 0) 65%); }
    #feedbackFlash.incorrect-flash { background: radial-gradient(circle, rgba(255, 71, 87, 0.4) 0%, rgba(255, 71, 87, 0.1) 40%, rgba(255, 71, 87, 0) 65%); }
    #feedbackFlash.active { opacity: 1; transition: opacity 0.05s ease; }
    
    .fragment-canvas { position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:9; }
    
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
    .modal-overlay.visible { opacity: 1; pointer-events: auto; }
    .modal-content { position: relative; width: 90vw; max-width: 500px; max-height: 80vh; overflow-y: auto; padding: 25px; transition: transform 0.3s cubic-bezier(0.22, 0.61, 0.36, 1), opacity 0.3s ease; transform: scale(0.9); opacity: 0; }
    .modal-overlay.visible .modal-content { transform: scale(1); opacity: 1; }
    .modal-close-btn { position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: rgba(0,0,0,0.3); color: white; border-radius: 50%; font-size: 16px; cursor: pointer; transition: all 0.2s ease; }
    .modal-close-btn:hover { background: rgba(255,0,0,0.5); transform: scale(1.1) rotate(90deg); }
    .modal-content h3 { text-align: center; margin-bottom: 20px; }
    .modal-dimension { margin-bottom: 18px; }
    .modal-dimension h4 { color: #879aff; margin-bottom: 5px; }
    .modal-dimension p { font-size: 0.9em; line-height: 1.6; opacity: 0.9; }

    @media (max-width:768px) { .dashboard-grid { grid-template-columns: 1fr; } }
    @media (max-width:480px) { .progress-bar{ width:260px; } .choice-btn { font-size: 18px; padding: 10px 20px; } .record-item { grid-template-columns: 1fr; } .record-stats { text-align: left; margin-top: 8px; } .summary-grid { grid-template-columns: repeat(2, 1fr); } }
  </style>
</head>
<body>
  <div class="floating-particles" id="particles"></div>

  <div class="game-container" id="controlContainer">
    <div class="game-panel control-panel">
      <h2>认知反应挑战</h2>
      <div class="form-group">
        <label for="difficultySelect">选择难度:</label>
        <select id="difficultySelect">
          <option value="easy">简单 (无限时)</option>
          <option value="medium" selected>中等 (5秒)</option>
          <option value="hard">困难 (3秒)</option>
        </select>
      </div>
      <div class="form-group">
        <label for="totalCount">题目数量:</label>
        <input type="number" id="totalCount" value="10" min="5" max="50">
      </div>
      <button id="startBtn">开始挑战</button>
    </div>
  </div>

  <div class="game-container hidden" id="gameScreen">
      <div class="timer-container">
          <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
      </div>
      <button id="stopBtn">终止</button>
      <div class="game-area">
          <div class="color-word" id="colorWord" aria-live="polite"></div>
          <div id="choiceContainer" class="choice-container"></div>
      </div>
      <div class="progress-container">
        <div class="progress-wrapper" id="progressWrapper">
            <div id="scoreDisplay" class="progress-text">得分: 0</div>
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        </div>
      </div>
  </div>

  <div class="game-container hidden" id="completionContainer">
      <div class="game-panel completion-message">
        <div id="completionTitle" class="completion-emoji">🎉</div>
        <h2>挑战完成!</h2>
        <p id="completionScore" class="score-text">正在生成您的认知分析报告...</p>
      </div>
  </div>

  <div class="game-container hidden" id="analysisReportContainer">
      <div class="game-panel" id="analysisReport">
        <div class="report-header">
          <h3 id="reportTitle">认知能力深度剖析</h3>
          <p id="reportSummary"></p>
        </div>

        <div class="dashboard-grid">
            <div class="dashboard-profile">
              <h4 class="dashboard-profile-title">
                认知能力雷达图 <i class="info-trigger" id="infoTrigger">i</i>
              </h4>
              <div class="radar-chart-container">
                <svg id="cognitiveProfileChart" class="radar-chart"></svg>
              </div>
            </div>

            <div class="dashboard-summary">
                <div class="summary-grid">
                  <div class="summary-item"><div class="value" id="summaryScore">0</div><div class="label">得分</div></div>
                  <div class="summary-item"><div class="value" id="summaryCEI">0</div><div class="label">认知效率</div></div>
                  <div class="summary-item"><div class="value" id="summaryAvgTime">0s</div><div class="label">平均反应</div></div>
                  <div class="summary-item"><div class="value" id="summaryAccuracy">0%</div><div class="label">准确率</div></div>
                </div>
                <div class="insight-box">
                    <h4 class="insight-title">您的认知画像: <span id="profileTypeName"></span></h4>
                    <div class="insight-content" id="summaryInsight"></div>
                </div>
            </div>
        </div>

        <div class="analysis-details">
            <div class="tabs-nav">
                <button class="tab-btn active" data-tab="trend">认知效率趋势</button>
                <button class="tab-btn" data-tab="records">历史记录</button>
            </div>
            <div class="tabs-content">
                <div class="tab-pane active" id="trendTabPane">
                    <svg id="trendChart" class="chart-svg"></svg>
                </div>
                <div class="tab-pane" id="recordsTabPane">
                    <div id="recordsList" class="records-list-container"></div>
                </div>
            </div>
        </div>
        
        <button id="playAgainBtn">再次挑战</button>
      </div>
  </div>
  
  <canvas class="fragment-canvas" id="fragmentCanvas"></canvas>
  <div id="feedbackFlash"></div>

  <div class="modal-overlay" id="explanationModal">
    <div class="game-panel modal-content">
      <button class="modal-close-btn" id="modalCloseBtn">&times;</button>
      <h3>认知维度解析</h3>
      <div class="modal-dimension">
        <h4>抑制控制 (Inhibitory Control)</h4>
        <p>衡量您抵抗干扰、专注于目标任务的能力。在本测试中，它体现为您能否忽略文字本身的含义，而专注于其颜色。分数主要基于您的**答题准确率**。</p>
      </div>
      <div class="modal-dimension">
        <h4>加工速度 (Processing Speed)</h4>
        <p>反映您大脑接收、理解并作出反应的效率。分数基于您的**平均反应时间**，用时越短，得分越高。</p>
      </div>
      <div class="modal-dimension">
        <h4>表现一致性 (Performance Consistency)</h4>
        <p>评估您在整个测试过程中表现的稳定性。如果您的每次反应时间都比较接近，说明您的认知状态稳定。分数基于您反应时间的**标准差**，波动越小，得分越高。</p>
      </div>
      <div class="modal-dimension">
        <h4>认知灵活性 (Cognitive Flexibility)</h4>
        <p>指您在不同思维模式或任务间切换的能力。高灵活性意味着您能高效地在“读字”和“辨色”两种冲突任务间进行切换。这是一个综合指标，由**准确率和加工速度**共同决定。</p>
      </div>
    </div>
  </div>


  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const elements = {
        controlContainer: document.getElementById('controlContainer'), gameScreen: document.getElementById('gameScreen'),
        difficultySelect: document.getElementById('difficultySelect'), totalCountInput: document.getElementById('totalCount'),
        startBtn: document.getElementById('startBtn'), stopBtn: document.getElementById('stopBtn'),
        timerFill: document.getElementById('timerFill'), colorWord: document.getElementById('colorWord'),
        choiceContainer: document.getElementById('choiceContainer'), progressWrapper: document.getElementById('progressWrapper'),
        scoreDisplay: document.getElementById('scoreDisplay'), progressFill: document.getElementById('progressFill'),
        completionContainer: document.getElementById('completionContainer'), completionTitle: document.getElementById('completionTitle'),
        completionScore: document.getElementById('completionScore'), analysisReportContainer: document.getElementById('analysisReportContainer'),
        playAgainBtn: document.getElementById('playAgainBtn'), reportTitle: document.getElementById('reportTitle'),
        reportSummary: document.getElementById('reportSummary'), summaryScore: document.getElementById('summaryScore'),
        summaryCEI: document.getElementById('summaryCEI'), summaryAvgTime: document.getElementById('summaryAvgTime'),
        summaryAccuracy: document.getElementById('summaryAccuracy'), profileTypeName: document.getElementById('profileTypeName'),
        summaryInsight: document.getElementById('summaryInsight'),
        cognitiveProfileChart: document.getElementById('cognitiveProfileChart'), trendChart: document.getElementById('trendChart'),
        recordsList: document.getElementById('recordsList'),
        fragmentCanvas: document.getElementById('fragmentCanvas'),
        infoTrigger: document.getElementById('infoTrigger'),
        explanationModal: document.getElementById('explanationModal'),
        modalCloseBtn: document.getElementById('modalCloseBtn'),
      };

      // --- 视觉特效 ---
      function triggerFeedbackFlash(isCorrect) {
          const flash = document.getElementById('feedbackFlash');
          flash.className = isCorrect ? 'correct-flash' : 'incorrect-flash';
          flash.classList.add('active');
          setTimeout(() => flash.classList.remove('active'), 150);
      }
      
      let activeFragmentAnimation = null;
      function triggerFragments(hexColor){
        const canvas = elements.fragmentCanvas;
        const ctx = canvas.getContext('2d');
        if(!ctx) return;
        
        const colorWord = elements.colorWord;
        const canvasRect = canvas.getBoundingClientRect();
        const cwRect = colorWord.getBoundingClientRect();
        if(cwRect.width === 0) return;

        const cx = cwRect.left + cwRect.width / 2 - canvasRect.left;
        const cy = cwRect.top + cwRect.height / 2 - canvasRect.top;
        
        let fragments = [];
        const particleCount = 60;
        for(let i = 0; i < particleCount; i++){
            const angle = Math.random() * Math.PI * 2;
            const speed = 5 + Math.random() * 10;
            fragments.push({ x: cx, y: cy, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 4 + Math.random() * 6, life: 0, maxLife: 60 + Math.random() * 40, color: hexColor });
        }
        animateFragments(fragments, ctx);
      }
      
      function animateFragments(fragments, ctx){
        const canvas = elements.fragmentCanvas;
        function frame(){
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for(let i = fragments.length - 1; i >= 0; i--){
            const f = fragments[i];
            f.x += f.vx; f.y += f.vy; f.vx *= 0.96; f.vy *= 0.96; f.vy += 0.15; f.life++;
            if(f.life >= f.maxLife){ fragments.splice(i, 1); continue; }
            const lifePercent = f.life / f.maxLife;
            const currentSize = f.size * (1 - lifePercent);
            ctx.beginPath();
            ctx.arc(f.x, f.y, Math.max(0, currentSize / 2), 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = 1 - lifePercent;
            ctx.fill();
          }
          if(fragments.length > 0) {
            activeFragmentAnimation = requestAnimationFrame(frame);
          } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(activeFragmentAnimation) cancelAnimationFrame(activeFragmentAnimation);
            activeFragmentAnimation = null;
          }
        }
        if (activeFragmentAnimation) cancelAnimationFrame(activeFragmentAnimation);
        activeFragmentAnimation = requestAnimationFrame(frame);
      }

      function createFloatingParticles() {
        const particlesContainer = document.getElementById('particles');
        if(particlesContainer.children.length > 0) return;
        const count = 40;
        for (let i = 0; i < count; i++) {
          let particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.top = `${Math.random() * 100}%`;
          particle.style.animationDelay = `${Math.random() * 8}s`;
          particle.style.transform = `scale(${Math.random() * 0.8 + 0.6})`;
          particle.style.opacity = Math.random() * 0.7 + 0.2;
          particlesContainer.appendChild(particle);
        }
      }

      const _COLORS_DATA = { '红':'#ff4757', '橙':'#ffa502', '黄':'#ffd32a', '绿':'#2ed573', '蓝':'#1e90ff', '紫':'#be2edd', '黑':'#2f3542', '白':'#ffffff' };
      const _COLOR_NAMES = Object.keys(_COLORS_DATA);
      const _DIFFICULTY_SETTINGS = {
        easy:   { time: Infinity, choices: 4, label: '简单' },
        medium: { time: 5000, choices: 4, label: '中等' },
        hard:   { time: 3000, choices: 6, label: '困难' }
      };
      
      let _gameState = {};

      function _resetGameState() {
          _gameState = { isRunning: false, difficulty: 'medium', totalCount: 10, currentCount: 0, score: 0, correctAnswer: '', timerId: null, roundStartTime: 0, correctCount: 0, reactionTimes: [] };
      }
      const _randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const _shuffleArray = (arr) => arr.sort(() => Math.random() - 0.5);

      function _switchScreen(from, to, onComplete = null) {
          if (from) from.classList.add('hidden');
          
          setTimeout(() => {
              if (from) from.style.display = 'none';
              if (to) {
                  const isFlexContainer = ['gameScreen', 'analysisReportContainer', 'controlContainer', 'completionContainer'].includes(to.id);
                  to.style.display = isFlexContainer ? 'flex' : 'block';
                  if(isFlexContainer) {
                      to.style.flexDirection = 'column';
                      to.style.alignItems = 'center';
                      to.style.justifyContent = 'center';
                  }
                  requestAnimationFrame(() => { 
                      to.classList.remove('hidden');
                      if (onComplete) onComplete();
                  });
              }
          }, 400);
      }
      
      function startGame() {
        if (_gameState.isRunning) return;
        _resetGameState();
        _gameState.isRunning = true;
        _gameState.difficulty = elements.difficultySelect.value;
        _gameState.totalCount = Math.max(1, parseInt(elements.totalCountInput.value) || 10);
        
        _switchScreen(elements.controlContainer, elements.gameScreen);

        updateProgress(0);
        setTimeout(nextRound, 500);
      }

      function stopGame() {
          if (!_gameState.isRunning) return;
          _gameState.isRunning = false;
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
          _switchScreen(elements.gameScreen, elements.controlContainer);
          _resetGameState();
      }

      function nextRound() {
        if (!_gameState.isRunning) return;
        if (_gameState.currentCount >= _gameState.totalCount) { endGame(); return; }
        clearForNextRound();
        let wordIndex, colorIndex;
        do { wordIndex = _randInt(0, _COLOR_NAMES.length - 1); colorIndex = _randInt(0, _COLOR_NAMES.length - 1); } while (wordIndex === colorIndex);
        
        const currentWord = _COLOR_NAMES[wordIndex];
        const currentColor = _COLORS_DATA[_COLOR_NAMES[colorIndex]];
        _gameState.correctAnswer = _COLOR_NAMES[colorIndex];
        
        elements.colorWord.textContent = currentWord;
        elements.colorWord.style.color = currentColor;
        elements.colorWord.classList.add('anim-enter');

        const choices = generateChoices(_gameState.correctAnswer, _DIFFICULTY_SETTINGS[_gameState.difficulty].choices);
        choices.forEach((choiceText, index) => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.textContent = choiceText;
            btn.onclick = (e) => handleChoice(e.target);
            elements.choiceContainer.appendChild(btn);
            btn.style.animationDelay = `${index * 80}ms`;
            btn.classList.add('anim-enter');
        });
        startTimer();
      }
      
      function handleChoice(buttonElement) {
          if (!_gameState.isRunning || Array.from(elements.choiceContainer.children).some(c => c.disabled)) return;
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
          document.querySelectorAll('.choice-btn').forEach(b => b.disabled = true);

          _gameState.currentCount++;
          const selectedAnswer = buttonElement.textContent;
          let isCorrect = selectedAnswer === _gameState.correctAnswer;
          let pointsAdded = 0;

          if (isCorrect) {
              _gameState.correctCount++;
              const timeTaken = performance.now() - _gameState.roundStartTime;
              const timeLimit = _DIFFICULTY_SETTINGS[_gameState.difficulty].time;
              let basePoints = 100, timeBonus = 0;
              if(timeLimit !== Infinity) {
                  _gameState.reactionTimes.push(timeTaken);
                  timeBonus = Math.max(0, Math.floor((1 - timeTaken / timeLimit) * 50));
              }
              pointsAdded = basePoints + timeBonus;
              _gameState.score += pointsAdded;
              triggerFeedbackFlash(true);
              triggerFragments(_COLORS_DATA[_gameState.correctAnswer]);
              elements.colorWord.classList.add('correct-feedback');
          } else {
              elements.colorWord.classList.add('incorrect-feedback');
              triggerFeedbackFlash(false);
          }

          updateProgress(pointsAdded);
          setTimeout(nextRound, 1000);
      }

      function endGame() {
          _gameState.isRunning = false;
          _switchScreen(elements.gameScreen, elements.completionContainer);
          saveCurrentRecord();
          setTimeout(showAnalysisReport, 2500);
      }
      
      function clearForNextRound() {
          elements.choiceContainer.innerHTML = '';
          elements.colorWord.className = 'color-word';
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
      }

      function generateChoices(correctAnswer, numChoices) {
          let choices = new Set([correctAnswer]);
          while(choices.size < numChoices) choices.add(_COLOR_NAMES[_randInt(0, _COLOR_NAMES.length - 1)]);
          return _shuffleArray(Array.from(choices));
      }
      
      function startTimer() {
          const timeLimit = _DIFFICULTY_SETTINGS[_gameState.difficulty].time;
          if (timeLimit === Infinity) { elements.timerFill.style.width = '100%'; return; }
          _gameState.roundStartTime = performance.now();
          elements.timerFill.style.transition = 'none';
          elements.timerFill.style.width = '100%';
          requestAnimationFrame(() => {
            setTimeout(() => {
                elements.timerFill.style.transition = `width ${timeLimit / 1000}s linear`;
                elements.timerFill.style.width = '0%';
            }, 50);
          });
          _gameState.timerId = setTimeout(() => { handleChoice({ textContent: null }); }, timeLimit);
      }

      function updateProgress(points) {
        elements.scoreDisplay.textContent = `得分: ${_gameState.score}`;
        elements.scoreDisplay.classList.remove('anim-update');
        void elements.scoreDisplay.offsetWidth;
        elements.scoreDisplay.classList.add('anim-update');
        if (points > 0) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            elements.progressWrapper.appendChild(popup);
            setTimeout(() => popup.remove(), 800);
        }
        const pct = _gameState.totalCount > 0 ? (_gameState.currentCount / _gameState.totalCount) * 100 : 0;
        elements.progressFill.style.width = pct + '%';
      }
      
      function getRecords() { return JSON.parse(localStorage.getItem('stroopChallengeHistory_G1.6')) || []; }
      function saveRecords(records) { localStorage.setItem('stroopChallengeHistory_G1.6', JSON.stringify(records)); }

      function calculateCEI(record) {
        if (!record) return 0;
        const accuracyFactor = record.accuracy;
        const avgTimeSeconds = record.avgTime > 0 ? record.avgTime / 1000 : 2.5;
        const speedFactor = Math.min(2.5, avgTimeSeconds);
        return Math.round(accuracyFactor * (100 / (speedFactor + 0.5)) * 1.5);
      }
      
      function saveCurrentRecord() {
        const accuracy = _gameState.totalCount > 0 ? _gameState.correctCount / _gameState.totalCount : 0;
        const avgTime = _gameState.reactionTimes.length > 0 ? _gameState.reactionTimes.reduce((a, b) => a + b, 0) / _gameState.reactionTimes.length : 0;
        const record = { timestamp: Date.now(), score: _gameState.score, accuracy: accuracy, avgTime: avgTime, difficulty: _gameState.difficulty, totalCount: _gameState.totalCount, reactionTimes: _gameState.reactionTimes };
        record.cei = calculateCEI(record);
        const records = getRecords();
        records.push(record);
        saveRecords(records);
      }

      function showAnalysisReport() {
        const allRecords = getRecords();
        const lastRecord = allRecords[allRecords.length - 1];
        if (!lastRecord) return;
        
        const profile = getCognitiveProfile(lastRecord);
        const profileType = getProfileType(profile);

        elements.summaryScore.textContent = lastRecord.score;
        elements.summaryCEI.textContent = lastRecord.cei;
        elements.summaryAvgTime.textContent = lastRecord.avgTime > 0 ? (lastRecord.avgTime / 1000).toFixed(2) + 's' : 'N/A';
        elements.summaryAccuracy.textContent = (lastRecord.accuracy * 100).toFixed(0) + '%';
        
        elements.profileTypeName.textContent = profileType.name;
        elements.summaryInsight.innerHTML = generatePersonalizedInsight(profile, profileType);
        
        elements.reportSummary.textContent = `本次 ${_DIFFICULTY_SETTINGS[lastRecord.difficulty].label} 难度, 共 ${lastRecord.totalCount} 题`;
        
        displayRecordsList(allRecords);

        _switchScreen(elements.completionContainer, elements.analysisReportContainer, () => {
            displayRadarChart(profile);
            displayTrendChart(allRecords);
            setupTabs();
        });
      }
      
      function displayRadarChart(profile) {
          const svg = elements.cognitiveProfileChart;
          svg.innerHTML = '';
          const size = Math.min(svg.clientWidth, svg.clientHeight);
          if(size === 0) return;
          const center = size / 2;
          const radius = size * 0.38;
          const levels = 4;
          const labels = Object.keys(profile);
          const numAxes = labels.length;

          for (let i = 1; i <= levels; i++) {
              const r = radius * (i / levels);
              let points = [];
              for (let j = 0; j < numAxes; j++) {
                  const angle = (j / numAxes) * 2 * Math.PI - Math.PI / 2;
                  points.push(`${center + r * Math.cos(angle)},${center + r * Math.sin(angle)}`);
              }
              svg.appendChild(createSVGElement('polygon', { points: points.join(' '), class: 'radar-grid' }));
              if (i % 2 === 0) {
                 const scaleLabel = createSVGElement('text', { x: center, y: center - r - 4, class: 'radar-scale-labels' });
                 scaleLabel.textContent = i * 25;
                 svg.appendChild(scaleLabel);
              }
          }

          labels.forEach((label, i) => {
              const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2;
              const x2 = center + radius * Math.cos(angle);
              const y2 = center + radius * Math.sin(angle);
              svg.appendChild(createSVGElement('line', { x1: center, y1: center, x2, y2, class: 'radar-axis' }));
              const lx = center + (radius + 20) * Math.cos(angle);
              const ly = center + (radius + 20) * Math.sin(angle);
              const text = createSVGElement('text', { x: lx, y: ly, class: 'radar-labels' });
              text.textContent = profile[label].label;
              svg.appendChild(text);
          });
          
          let dataPoints = [];
          labels.forEach((label, i) => {
              const value = profile[label].score / 100;
              const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2;
              const x = center + radius * value * Math.cos(angle);
              const y = center + radius * value * Math.sin(angle);
              dataPoints.push(`${x},${y}`);
              svg.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 4, class: 'radar-point' }));
          });
          
          const area = createSVGElement('polygon', { points: dataPoints.join(' '), class: 'radar-area' });
          const initialPoints = new Array(numAxes).fill(`${center},${center}`).join(' ');
          area.innerHTML = `<animate attributeName="points" from="${initialPoints}" to="${dataPoints.join(' ')}" dur="0.7s" fill="freeze" calcMode="spline" keySplines="0.25 0.1 0.25 1" />`;
          svg.appendChild(area);
      }
      
      function displayTrendChart(records) {
        const svg = elements.trendChart;
        svg.innerHTML = '';
        const recentRecords = records.slice(-15);
        if (recentRecords.length < 2) { svg.innerHTML = '<text x="50%" y="50%" fill="white" text-anchor="middle">完成更多挑战以生成趋势图...</text>'; return; }

        const { width, height } = svg.getBoundingClientRect();
        if(width === 0) return;
        const padding = { top: 20, right: 35, bottom: 30, left: 30 };
        const data = recentRecords.map(r => r.cei);
        
        const maxVal = Math.ceil(Math.max(...data, 0) / 10) * 10;
        const minVal = 0;
        const avgVal = data.reduce((a, b) => a + b, 0) / data.length;

        const getX = (i) => padding.left + (width - padding.left - padding.right) * (i / (data.length - 1));
        const getY = (val) => height - padding.bottom - (height - padding.top - padding.bottom) * ((val - minVal) / (maxVal - minVal || 1));

        const yAxis = createSVGElement('g', { class: 'chart-axis' });
        [minVal, Math.round(avgVal), maxVal].forEach(val => {
          if (isNaN(val) || val > maxVal) return;
          const y = getY(val);
          yAxis.appendChild(createSVGElement('line', { x1: padding.left, y1: y, x2: width - padding.right, y2: y, class: 'chart-axis-line', 'stroke-dasharray': val === Math.round(avgVal) ? '4,4' : '2,2', 'stroke': val === Math.round(avgVal) ? '#879aff' : 'rgba(255,255,255,0.3)' }));
          const text = createSVGElement('text', { x: padding.left - 5, y: y + 4, class: 'chart-axis-text', 'text-anchor': 'end' });
          text.textContent = val;
          yAxis.appendChild(text);
        });
        svg.appendChild(yAxis);
        
        const xAxis = createSVGElement('g', { class: 'chart-axis' });
        data.forEach((_, i) => {
            const x = getX(i);
            const text = createSVGElement('text', { x: x, y: height - padding.bottom + 15, class: 'chart-axis-text', 'text-anchor': 'middle' });
            text.textContent = `#${records.length - recentRecords.length + i + 1}`;
            xAxis.appendChild(text);
        });
        svg.appendChild(xAxis);
        
        const defs = createSVGElement('defs');
        const gradient = createSVGElement('linearGradient', { id: 'chartGradient', x1: '0%', y1: '0%', x2: '0%', y2: '100%' });
        gradient.innerHTML = `<stop offset="0%" stop-color="#4ecdc4" stop-opacity="0.6"/> <stop offset="100%" stop-color="#4ecdc4" stop-opacity="0"/>`;
        defs.appendChild(gradient);
        svg.appendChild(defs);

        let linePath = `M ${getX(0)} ${getY(data[0])}`;
        let areaPath = `M ${getX(0)} ${height - padding.bottom} L ${getX(0)} ${getY(data[0])}`;
        for (let i = 1; i < data.length; i++) {
            linePath += ` L ${getX(i)} ${getY(data[i])}`;
            areaPath += ` L ${getX(i)} ${getY(data[i])}`;
        }
        areaPath += ` L ${getX(data.length-1)} ${height - padding.bottom} Z`;

        svg.appendChild(createSVGElement('path', { d: areaPath, class: 'chart-area' }));
        svg.appendChild(createSVGElement('path', { d: linePath, class: 'chart-line' }));

        data.forEach((val, i) => {
          const point = createSVGElement('circle', { cx: getX(i), cy: getY(val), r: 4, class: 'chart-point' });
          point.innerHTML = `<title>第${records.length - recentRecords.length + i + 1}次 - CEI: ${val}</title>`;
          svg.appendChild(point);
        });
      }

      function displayRecordsList(records) {
        elements.recordsList.innerHTML = '';
        if (records.length === 0) {
            elements.recordsList.innerHTML += '<div style="text-align:center; padding: 20px; color: rgba(255,255,255,0.7);">暂无记录</div>';
            return;
        }
        const pbScore = Math.max(...records.map(r => r.score));
        const recentRecords = records.slice().reverse().slice(0, 10);
        recentRecords.forEach(r => {
            const isPb = r.score === pbScore;
            const item = document.createElement('div');
            item.className = 'record-item' + (isPb ? ' is-pb' : '');
            item.innerHTML = `
                <div>
                    <div class="record-details-main">${_DIFFICULTY_SETTINGS[r.difficulty].label} - ${r.totalCount}题</div>
                    <div class="record-details-sub">
                        <span>${new Date(r.timestamp).toLocaleDateString()}</span>
                        <span>准确率: ${(r.accuracy * 100).toFixed(0)}%</span>
                        <span>反应: ${r.avgTime > 0 ? (r.avgTime/1000).toFixed(2)+'s' : 'N/A'}</span>
                    </div>
                </div>
                <div class="record-stats">CEI: ${r.cei}</div>`;
            elements.recordsList.appendChild(item);
        });
      }

      // --- Cognitive Model & Analysis ---
      function getCognitiveProfile(record) {
          const accuracyScore = record.accuracy * 100;
          const speedScore = Math.max(0, Math.min(100, 100 - ((record.avgTime || 2500) - 500) / 20));
          const stdDev = getStandardDeviation(record.reactionTimes);
          const consistencyScore = Math.max(0, Math.min(100, 100 - ((stdDev || 500) - 50) / 4.5));
          const flexibilityScore = (accuracyScore * 0.5) + (speedScore * 0.5);

          return {
              inhibitoryControl: { label: "抑制控制", score: accuracyScore },
              processingSpeed: { label: "加工速度", score: speedScore },
              performanceConsistency: { label: "表现一致性", score: consistencyScore },
              cognitiveFlexibility: { label: "认知灵活性", score: flexibilityScore },
          };
      }

      function getProfileType(profile) {
          const ic = profile.inhibitoryControl.score;
          const ps = profile.processingSpeed.score;
          const pc = profile.performanceConsistency.score;
          
          if (ps > 85 && ic > 90) return { name: "敏锐反应者", description: "您拥有闪电般的反应速度和出色的抗干扰能力。" };
          if (pc > 85 && ic > 85) return { name: "沉稳策略家", description: "您表现稳定，准确率高，展现出冷静和专注的特质。" };
          if (ic > 80 && ps > 80 && pc > 80) return { name: "均衡全能型", description: "您的各项认知能力均衡发展，综合表现优秀。" };
          if (ic > 90 && ps < 70) return { name: "细致思考者", description: "您追求极致的准确性，表现出严谨细致的思维风格。" };
          return { name: "潜力发展型", description: "您在本次挑战中展现了潜力，持续练习将带来显著提升。" };
      }
      
      function generatePersonalizedInsight(profile, profileType) {
          let insightHTML = `<p>${profileType.description}</p>`;
          const scores = Object.values(profile).sort((a,b) => b.score - a.score);
          const strongest = scores[0];
          const weakest = scores[scores.length - 1];

          insightHTML += `<p style="margin-top:10px;"><strong>优势分析:</strong> 您的「${strongest.label}」表现突出 (${Math.round(strongest.score)}分)，这说明您能高效地处理任务并保持专注。</p>`;
          insightHTML += `<p><em>提升建议:</em> 关注「${weakest.label}」(${Math.round(weakest.score)}分)的练习，尝试在保证速度的同时维持稳定表现，可以帮助您获得更全面的提升。</p>`;

          return insightHTML;
      }

      function getStandardDeviation(array) {
        if (!array || array.length < 2) return 0;
        const n = array.length;
        const mean = array.reduce((a, b) => a + b) / n;
        return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
      }
      
      function createSVGElement(tag, attrs) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const key in attrs) { el.setAttribute(key, attrs[key]); }
        return el;
      }
      
      function setupTabs() {
          const tabContainer = document.querySelector('.analysis-details');
          const tabBtns = tabContainer.querySelectorAll('.tab-btn');
          const tabPanes = tabContainer.querySelectorAll('.tab-pane');

          tabBtns.forEach(btn => {
              btn.addEventListener('click', () => {
                  tabBtns.forEach(b => b.classList.remove('active'));
                  btn.classList.add('active');
                  const targetTab = btn.getAttribute('data-tab');
                  tabPanes.forEach(pane => {
                      pane.classList.remove('active');
                      if(pane.id === `${targetTab}TabPane`) {
                          pane.classList.add('active');
                      }
                  });
              });
          });
      }

      function init() {
          const canvas = elements.fragmentCanvas;
          _resetGameState();
          createFloatingParticles();
          const resizeCanvas = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
          resizeCanvas();
          elements.startBtn.addEventListener('click', startGame);
          elements.stopBtn.addEventListener('click', stopGame);
          elements.playAgainBtn.addEventListener('click', () => { 
            _switchScreen(elements.analysisReportContainer, elements.controlContainer); 
          });
          elements.infoTrigger.addEventListener('click', () => elements.explanationModal.classList.add('visible'));
          elements.modalCloseBtn.addEventListener('click', () => elements.explanationModal.classList.remove('visible'));
          elements.explanationModal.addEventListener('click', (e) => {
             if (e.target === elements.explanationModal) elements.explanationModal.classList.remove('visible');
          });
          
          window.addEventListener('resize', () => {
              resizeCanvas();
              if (!elements.analysisReportContainer.classList.contains('hidden')) {
                  showAnalysisReport();
              }
          });
      }
      
      init();
    });
  </script>
</body>
</html>


G1.6 
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>认知反应挑战 G1.6</title>
  <style>
    /* reset */
    * { margin:0; padding:0; box-sizing:border-box; }
    html { scroll-behavior: smooth; }
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100dvh;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction: column;
      overflow-y: auto;
      overflow-x: hidden;
      background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c, #4facfe, #00f2fe);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      -webkit-tap-highlight-color: transparent;
      color: white;
    }
    @keyframes gradientShift { 0%, 100% { background-position: 0% 50%; } 25% { background-position: 100% 50%; } 50% { background-position: 100% 100%; } 75% { background-position: 0% 100%; } }

    .floating-particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
    .particle { position: absolute; width: 6px; height: 6px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; animation: float 8s ease-in-out infinite; }
    @keyframes float { 0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 1; } 50% { transform: translateY(-25px) rotate(180deg); opacity: 0.4; } }

    .game-container {
      position: relative; z-index: 2;
      transition: opacity 0.4s cubic-bezier(0.22, 0.61, 0.36, 1), transform 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
      margin: 20px 0;
    }
    .game-container.hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.95) translateY(10px);
      display: none !important; /* Use important to ensure it's hidden */
    }
    .game-panel {
        background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 25px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        border: 2px solid rgba(255,255,255,0.1);
    }
    .game-panel::before {
      content: ''; position: absolute; top: -2px; left: -2px; right: -2px; bottom: -2px;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7, #dda0dd);
      border-radius: 27px; z-index: -1; animation: borderGlow 3s ease-in-out infinite alternate;
    }
    @keyframes borderGlow { 0% { opacity: 0.5; transform: scale(1); } 100% { opacity: 1; transform: scale(1.02); } }

    .control-panel {
      padding: 30px;
      display:flex; gap: 18px; align-items:center; flex-direction: column;
      width: 90vw; max-width: 420px;
    }
    .control-panel h2 { font-size: 24px; font-weight: 700; margin-bottom: 10px; }
    .control-panel .form-group { display: flex; align-items: center; gap: 10px; width: 100%; justify-content: space-between; }
    .control-panel label { font-weight: 600; font-size: 16px; }
    .control-panel select,
    .control-panel input[type="number"]{
      padding:10px 14px; border: 1px solid rgba(255,255,255,0.1); border-radius:10px;
      width:160px; font-size:16px; text-align:center; background:rgba(0,0,0,0.1); color: white;
      transition: all 0.25s ease;
    }
    .control-panel select:focus,
    .control-panel input[type="number"]:focus {
      outline: none; border-color: #879aff; box-shadow: 0 0 0 4px rgba(135, 154, 255, 0.3);
    }
    .control-panel button{
      margin-top: 15px; padding:14px 35px;
      background: linear-gradient(45deg,#ff6b6b,#f0932b);
      color:white; border:none; border-radius:30px; font-size:18px; font-weight:bold;
      cursor:pointer; transition: all .2s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow:0 5px 20px rgba(238,90,36,0.3);
    }
    .control-panel button:hover{ transform: translateY(-5px) scale(1.05); box-shadow:0 10px 30px rgba(238,90,36,0.4); }

    #gameScreen {
      position: fixed; inset:0;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: 20px 0;
    }
    .timer-container { width: 100%; padding: 15px; position: absolute; top: 0; z-index: 120; }
    .timer-bar { width: 95%; max-width: 600px; margin: 0 auto; height: 8px; background-color: rgba(255,255,255,0.25); border-radius: 4px; overflow: hidden; }
    .timer-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #84fab0 0%, #8fd3f4 100%); border-radius: 4px; }
    .game-area { width: 100%; flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5vh; padding: 20px; min-height: 250px; }
    
    .color-word{
        font-size: clamp(80px, 28vmin, 200px);
        font-weight:bold; user-select:none;
        opacity: 0;
    }
    .color-word.anim-enter { animation: word-enter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    @keyframes word-enter { from { transform: scale(0.6) translateY(-20px) rotate(-5deg); opacity: 0; } to { transform: scale(1) translateY(0) rotate(0deg); opacity: 1; } }
    .choice-container { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; padding: 0 10px; }
    .choice-btn {
        padding: 14px 30px; font-size: 20px; font-weight: bold; color: #333; background: rgba(255, 255, 255, 0.98);
        border: none; border-radius: 14px; cursor: pointer;
        box-shadow: 0 5px 25px rgba(0,0,0,0.1); opacity: 0; transform: translateY(30px);
        transition: all 0.2s cubic-bezier(0.22, 0.61, 0.36, 1);
    }
    .choice-btn.anim-enter { animation: button-enter 0.5s cubic-bezier(0.22, 0.61, 0.36, 1) forwards; }
    @keyframes button-enter { to { opacity: 1; transform: translateY(0); } }
    .choice-btn:hover { transform: translateY(-6px) scale(1.04); box-shadow: 0 10px 35px rgba(0,0,0,0.15); }

    #stopBtn {
        position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.2);
        backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); color: white; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; cursor: pointer; z-index: 130; transition: all 0.2s ease;
    }
    #stopBtn:hover { background: rgba(0,0,0,0.4); transform: scale(1.05); }
    .progress-container { flex-shrink: 0; padding-bottom: 20px; }
    .progress-wrapper { background: rgba(0,0,0,0.22); padding: 10px 20px; border-radius:15px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); text-align: center; user-select:none; position: relative; }
    #scoreDisplay.anim-update { animation: score-update 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
    @keyframes score-update { 50% { transform: scale(1.25); } }
    .progress-bar{ width:320px; height:8px; background: rgba(255,255,255,0.2); border-radius:4px; overflow:hidden; }
    .progress-fill{ height:100%; width:0%; border-radius:4px; background: #fff; transition: width .4s cubic-bezier(0.22, 0.61, 0.36, 1); }
    .score-popup { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); font-size: 18px; font-weight: bold; color: #2ed573; animation: score-popup-anim 0.8s ease-out forwards; pointer-events: none; }
    @keyframes score-popup-anim { from { opacity: 1; transform: translate(-50%, 0); } to { opacity: 0; transform: translate(-50%, -40px); } }

    .completion-message {
      padding:25px; text-align:center;
      min-width:280px; display:flex; flex-direction:column; gap:12px;
    }
    .completion-emoji{ font-size:40px; }
    .score-text { font-size: 18px; }

    /* --- Report Screen Styles (REVISED) --- */
    #analysisReportContainer {
      display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px 0;
    }
    #analysisReport {
      max-width: 860px; width: 90vw; padding: 25px;
      max-height: 85vh; overflow-y: auto; text-align: left;
    }
    .report-header { text-align: center; margin-bottom: 20px; }
    .report-header h3 { font-size: 2rem; font-weight: 900; }
    .report-header p { font-size: 1.1rem; opacity: 0.9; margin-top: 5px; }

    .dashboard-grid { display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 25px; }
    .dashboard-profile { background: rgba(0,0,0,0.2); padding: 15px; border-radius: 15px; }
    .dashboard-profile-title { display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 10px; font-size: 1.1em; color: rgba(255,255,255,0.7); }
    .info-trigger { cursor: pointer; font-style: normal; font-weight: bold; width: 18px; height: 18px; border: 1.5px solid rgba(255,255,255,0.5); border-radius: 50%; display: inline-flex; justify-content: center; align-items: center; font-size: 12px; transition: all 0.2s ease; }
    .info-trigger:hover { background: rgba(255,255,255,0.2); transform: scale(1.1); }

    .radar-chart-container { position: relative; width: 100%; max-width: 300px; aspect-ratio: 1; display: flex; align-items: center; justify-content: center; margin: 0 auto; }
    .radar-chart { width: 100%; height: 100%; }
    .radar-grid { stroke: rgba(255,255,255,0.2); stroke-width: 1; fill: none; }
    .radar-axis { stroke: rgba(255,255,255,0.3); stroke-width: 1; }
    .radar-area { fill: rgba(78, 205, 196, 0.4); stroke: #4ecdc4; stroke-width: 2; }
    .radar-point { fill: #4ecdc4; stroke: white; stroke-width: 2px; }
    .radar-labels { font-size: clamp(9px, 2.5vw, 12px); fill: white; text-anchor: middle; }
    .radar-scale-labels { font-size: 10px; fill: rgba(255,255,255,0.5); text-anchor: middle; }

    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; text-align: center; margin-bottom: 20px; }
    .summary-item .value { font-size: 1.8rem; font-weight: bold; color: #879aff; }
    .summary-item .label { font-size: 0.8rem; color: rgba(255,255,255,0.7); }
    
    .insight-box { background: rgba(0,0,0,0.15); padding: 15px; border-radius: 10px; }
    .insight-title { text-align: center; margin-bottom: 15px; font-size: 1.2em; font-weight: bold; }
    #profileTypeName { color: #f1c40f; }
    .insight-content { font-size: 0.9em; line-height: 1.6; }
    .insight-content strong { color: #2ed573; } /* Strength */
    .insight-content em { color: #ff6b6b; font-style: normal; } /* Improvement Area */

    .analysis-details { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 15px; margin-top: 20px; }
    .tabs-nav { display: flex; justify-content: center; gap: 10px; margin-bottom: 15px; }
    .tab-btn { padding: 8px 20px; background: rgba(255,255,255,0.1); border: none; color: white; border-radius: 20px; cursor: pointer; transition: all 0.25s ease; font-size: 15px; }
    .tab-btn:hover { background: rgba(255,255,255,0.2); }
    .tab-btn.active { background: #879aff; font-weight: bold; }
    .tab-pane { display: none; animation: fadeIn 0.5s ease; }
    .tab-pane.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .chart-svg { width: 100%; height: 200px; }
    .chart-axis, .chart-axis-line { stroke: rgba(255,255,255,0.3); stroke-width: 1; }
    .chart-axis-text { fill: rgba(255,255,255,0.6); font-size: 10px; }
    .chart-line{fill:none;stroke:#4ecdc4;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;animation:draw-line 1.5s ease-out forwards}.chart-area{fill:url(#chartGradient);opacity:.5;animation:fade-in 1s ease-out forwards}.chart-point{fill:#f1c40f;stroke:rgba(0,0,0,.5);stroke-width:2;transition:r .3s ease}.chart-point:hover{r:7}.chart-avg-line{stroke:#879aff;stroke-width:1.5;stroke-dasharray:4,4}@keyframes draw-line{from{stroke-dasharray:1000;stroke-dashoffset:1000}to{stroke-dasharray:1000;stroke-dashoffset:0}}@keyframes fade-in{from{opacity:0}to{opacity:.5}}
    
    .records-list-container { max-height: 300px; overflow-y: auto; padding-right: 5px; }
    .record-item { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 15px; padding: 12px 10px; border-bottom: 1px solid rgba(255,255,255,0.1); transition: all 0.3s ease; }
    .record-item:last-child { border-bottom: none; }
    .record-item:hover { background: rgba(255, 255, 255, 0.05); transform: translateX(5px); }
    .record-item.is-pb { border-left: 4px solid #f1c40f; padding-left: 6px; }
    .record-details-main { font-size: 0.9em; }
    .record-details-sub { font-size: 0.8em; opacity: 0.7; display: flex; gap: 10px; margin-top: 4px; flex-wrap: wrap; }
    .record-stats { text-align: right; font-weight: bold; font-size: 1.1em; color: #f1c40f; }
    .record-item:not(.is-pb) .record-stats { color: white; }

    #playAgainBtn {
      margin: 25px auto 0; padding: 14px 35px;
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      box-shadow: 0 5px 20px rgba(46, 213, 115, 0.3); color: white; border: none; font-weight: bold; font-size: 18px; border-radius: 30px;
      cursor: pointer; transition: all .2s cubic-bezier(0.34, 1.56, 0.64, 1); display: block;
    }
    #playAgainBtn:hover { transform: translateY(-5px) scale(1.05); box-shadow: 0 10px 30px rgba(46, 213, 115, 0.4); }
    
    .color-word.correct-feedback { animation: bounce-correct 0.6s ease; }
    .color-word.incorrect-feedback { animation: shake-horizontal 0.5s cubic-bezier(.36,.07,.19,.97); }
    @keyframes bounce-correct { 0%, 100% { transform: translateY(0); } 20% { transform: translateY(-20px); } 50% { transform: translateY(5px); } 80% { transform: translateY(-10px); } }
    @keyframes shake-horizontal { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    
    #feedbackFlash { position: fixed; inset: 0; z-index: 210; opacity: 0; pointer-events: none; transition: opacity 0.4s ease; }
    #feedbackFlash.correct-flash { background: radial-gradient(circle, rgba(46, 213, 115, 0.4) 0%, rgba(46, 213, 115, 0.1) 40%, rgba(46, 213, 115, 0) 65%); }
    #feedbackFlash.incorrect-flash { background: radial-gradient(circle, rgba(255, 71, 87, 0.4) 0%, rgba(255, 71, 87, 0.1) 40%, rgba(255, 71, 87, 0) 65%); }
    #feedbackFlash.active { opacity: 1; transition: opacity 0.05s ease; }
    
    .fragment-canvas { position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:9; }
    
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
    .modal-overlay.visible { opacity: 1; pointer-events: auto; }
    .modal-content { position: relative; width: 90vw; max-width: 500px; max-height: 80vh; overflow-y: auto; padding: 25px; transition: transform 0.3s cubic-bezier(0.22, 0.61, 0.36, 1), opacity 0.3s ease; transform: scale(0.9); opacity: 0; }
    .modal-overlay.visible .modal-content { transform: scale(1); opacity: 1; }
    .modal-close-btn { position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; border: none; background: rgba(0,0,0,0.3); color: white; border-radius: 50%; font-size: 16px; cursor: pointer; transition: all 0.2s ease; }
    .modal-close-btn:hover { background: rgba(255,0,0,0.5); transform: scale(1.1) rotate(90deg); }
    .modal-content h3 { text-align: center; margin-bottom: 20px; }
    .modal-dimension { margin-bottom: 18px; }
    .modal-dimension h4 { color: #879aff; margin-bottom: 5px; }
    .modal-dimension p { font-size: 0.9em; line-height: 1.6; opacity: 0.9; }

    @media (max-width:768px) { .dashboard-grid { grid-template-columns: 1fr; } }
    @media (max-width:480px) { .progress-bar{ width:260px; } .choice-btn { font-size: 18px; padding: 10px 20px; } .record-item { grid-template-columns: 1fr; } .record-stats { text-align: left; margin-top: 8px; } .summary-grid { grid-template-columns: repeat(2, 1fr); } }
  </style>
</head>
<body>
  <div class="floating-particles" id="particles"></div>

  <div class="game-container" id="controlContainer">
    <div class="game-panel control-panel">
      <h2>认知反应挑战</h2>
      <div class="form-group">
        <label for="difficultySelect">选择难度:</label>
        <select id="difficultySelect">
          <option value="easy">简单 (无限时)</option>
          <option value="medium" selected>中等 (5秒)</option>
          <option value="hard">困难 (3秒)</option>
        </select>
      </div>
      <div class="form-group">
        <label for="totalCount">题目数量:</label>
        <input type="number" id="totalCount" value="10" min="5" max="50">
      </div>
      <button id="startBtn">开始挑战</button>
    </div>
  </div>

  <div class="game-container hidden" id="gameScreen">
      <div class="timer-container">
          <div class="timer-bar"><div class="timer-fill" id="timerFill"></div></div>
      </div>
      <button id="stopBtn">终止</button>
      <div class="game-area">
          <div class="color-word" id="colorWord" aria-live="polite"></div>
          <div id="choiceContainer" class="choice-container"></div>
      </div>
      <div class="progress-container">
        <div class="progress-wrapper" id="progressWrapper">
            <div id="scoreDisplay" class="progress-text">得分: 0</div>
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        </div>
      </div>
  </div>

  <div class="game-container hidden" id="completionContainer">
      <div class="game-panel completion-message">
        <div id="completionTitle" class="completion-emoji">🎉</div>
        <h2>挑战完成!</h2>
        <p id="completionScore" class="score-text">正在生成您的认知分析报告...</p>
      </div>
  </div>

  <div class="game-container hidden" id="analysisReportContainer">
      <div class="game-panel" id="analysisReport">
        <div class="report-header">
          <h3 id="reportTitle">认知能力深度剖析</h3>
          <p id="reportSummary"></p>
        </div>

        <div class="dashboard-grid">
            <div class="dashboard-profile">
              <h4 class="dashboard-profile-title">
                认知能力雷达图 <i class="info-trigger" id="infoTrigger">i</i>
              </h4>
              <div class="radar-chart-container">
                <svg id="cognitiveProfileChart" class="radar-chart"></svg>
              </div>
            </div>

            <div class="dashboard-summary">
                <div class="summary-grid">
                  <div class="summary-item"><div class="value" id="summaryScore">0</div><div class="label">得分</div></div>
                  <div class="summary-item"><div class="value" id="summaryCEI">0</div><div class="label">认知效率</div></div>
                  <div class="summary-item"><div class="value" id="summaryAvgTime">0s</div><div class="label">平均反应</div></div>
                  <div class="summary-item"><div class="value" id="summaryAccuracy">0%</div><div class="label">准确率</div></div>
                </div>
                <div class="insight-box">
                    <h4 class="insight-title">您的认知画像: <span id="profileTypeName"></span></h4>
                    <div class="insight-content" id="summaryInsight"></div>
                </div>
            </div>
        </div>

        <div class="analysis-details">
            <div class="tabs-nav">
                <button class="tab-btn active" data-tab="trend">认知效率趋势</button>
                <button class="tab-btn" data-tab="records">历史记录</button>
            </div>
            <div class="tabs-content">
                <div class="tab-pane active" id="trendTabPane">
                    <svg id="trendChart" class="chart-svg"></svg>
                </div>
                <div class="tab-pane" id="recordsTabPane">
                    <div id="recordsList" class="records-list-container"></div>
                </div>
            </div>
        </div>
        
        <button id="playAgainBtn">再次挑战</button>
      </div>
  </div>
  
  <canvas class="fragment-canvas" id="fragmentCanvas"></canvas>
  <div id="feedbackFlash"></div>

  <div class="modal-overlay" id="explanationModal">
    <div class="game-panel modal-content">
      <button class="modal-close-btn" id="modalCloseBtn">&times;</button>
      <h3>认知维度解析</h3>
      <div class="modal-dimension">
        <h4>抑制控制 (Inhibitory Control)</h4>
        <p>衡量您抵抗干扰、专注于目标任务的能力。在本测试中，它体现为您能否忽略文字本身的含义，而专注于其颜色。分数主要基于您的**答题准确率**。</p>
      </div>
      <div class="modal-dimension">
        <h4>加工速度 (Processing Speed)</h4>
        <p>反映您大脑接收、理解并作出反应的效率。分数基于您的**平均反应时间**，用时越短，得分越高。</p>
      </div>
      <div class="modal-dimension">
        <h4>表现一致性 (Performance Consistency)</h4>
        <p>评估您在整个测试过程中表现的稳定性。如果您的每次反应时间都比较接近，说明您的认知状态稳定。分数基于您反应时间的**标准差**，波动越小，得分越高。</p>
      </div>
      <div class="modal-dimension">
        <h4>认知灵活性 (Cognitive Flexibility)</h4>
        <p>指您在不同思维模式或任务间切换的能力。高灵活性意味着您能高效地在“读字”和“辨色”两种冲突任务间进行切换。这是一个综合指标，由**准确率和加工速度**共同决定。</p>
      </div>
    </div>
  </div>


  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const elements = {
        controlContainer: document.getElementById('controlContainer'), gameScreen: document.getElementById('gameScreen'),
        difficultySelect: document.getElementById('difficultySelect'), totalCountInput: document.getElementById('totalCount'),
        startBtn: document.getElementById('startBtn'), stopBtn: document.getElementById('stopBtn'),
        timerFill: document.getElementById('timerFill'), colorWord: document.getElementById('colorWord'),
        choiceContainer: document.getElementById('choiceContainer'), progressWrapper: document.getElementById('progressWrapper'),
        scoreDisplay: document.getElementById('scoreDisplay'), progressFill: document.getElementById('progressFill'),
        completionContainer: document.getElementById('completionContainer'), completionTitle: document.getElementById('completionTitle'),
        completionScore: document.getElementById('completionScore'), analysisReportContainer: document.getElementById('analysisReportContainer'),
        playAgainBtn: document.getElementById('playAgainBtn'), reportTitle: document.getElementById('reportTitle'),
        reportSummary: document.getElementById('reportSummary'), summaryScore: document.getElementById('summaryScore'),
        summaryCEI: document.getElementById('summaryCEI'), summaryAvgTime: document.getElementById('summaryAvgTime'),
        summaryAccuracy: document.getElementById('summaryAccuracy'), profileTypeName: document.getElementById('profileTypeName'),
        summaryInsight: document.getElementById('summaryInsight'),
        cognitiveProfileChart: document.getElementById('cognitiveProfileChart'), trendChart: document.getElementById('trendChart'),
        recordsList: document.getElementById('recordsList'),
        fragmentCanvas: document.getElementById('fragmentCanvas'),
        infoTrigger: document.getElementById('infoTrigger'),
        explanationModal: document.getElementById('explanationModal'),
        modalCloseBtn: document.getElementById('modalCloseBtn'),
      };

      // --- 视觉特效 ---
      function triggerFeedbackFlash(isCorrect) {
          const flash = document.getElementById('feedbackFlash');
          flash.className = isCorrect ? 'correct-flash' : 'incorrect-flash';
          flash.classList.add('active');
          setTimeout(() => flash.classList.remove('active'), 150);
      }
      
      let activeFragmentAnimation = null;
      function triggerFragments(hexColor){
        const canvas = elements.fragmentCanvas;
        const ctx = canvas.getContext('2d');
        if(!ctx) return;
        
        const colorWord = elements.colorWord;
        const canvasRect = canvas.getBoundingClientRect();
        const cwRect = colorWord.getBoundingClientRect();
        if(cwRect.width === 0) return;

        const cx = cwRect.left + cwRect.width / 2 - canvasRect.left;
        const cy = cwRect.top + cwRect.height / 2 - canvasRect.top;
        
        let fragments = [];
        const particleCount = 60;
        for(let i = 0; i < particleCount; i++){
            const angle = Math.random() * Math.PI * 2;
            const speed = 5 + Math.random() * 10;
            fragments.push({ x: cx, y: cy, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 4 + Math.random() * 6, life: 0, maxLife: 60 + Math.random() * 40, color: hexColor });
        }
        animateFragments(fragments, ctx);
      }
      
      function animateFragments(fragments, ctx){
        const canvas = elements.fragmentCanvas;
        function frame(){
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for(let i = fragments.length - 1; i >= 0; i--){
            const f = fragments[i];
            f.x += f.vx; f.y += f.vy; f.vx *= 0.96; f.vy *= 0.96; f.vy += 0.15; f.life++;
            if(f.life >= f.maxLife){ fragments.splice(i, 1); continue; }
            const lifePercent = f.life / f.maxLife;
            const currentSize = f.size * (1 - lifePercent);
            ctx.beginPath();
            ctx.arc(f.x, f.y, Math.max(0, currentSize / 2), 0, Math.PI * 2);
            ctx.fillStyle = f.color;
            ctx.globalAlpha = 1 - lifePercent;
            ctx.fill();
          }
          if(fragments.length > 0) {
            activeFragmentAnimation = requestAnimationFrame(frame);
          } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(activeFragmentAnimation) cancelAnimationFrame(activeFragmentAnimation);
            activeFragmentAnimation = null;
          }
        }
        if (activeFragmentAnimation) cancelAnimationFrame(activeFragmentAnimation);
        activeFragmentAnimation = requestAnimationFrame(frame);
      }

      function createFloatingParticles() {
        const particlesContainer = document.getElementById('particles');
        if(particlesContainer.children.length > 0) return;
        const count = 40;
        for (let i = 0; i < count; i++) {
          let particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.top = `${Math.random() * 100}%`;
          particle.style.animationDelay = `${Math.random() * 8}s`;
          particle.style.transform = `scale(${Math.random() * 0.8 + 0.6})`;
          particle.style.opacity = Math.random() * 0.7 + 0.2;
          particlesContainer.appendChild(particle);
        }
      }

      const _COLORS_DATA = { '红':'#ff4757', '橙':'#ffa502', '黄':'#ffd32a', '绿':'#2ed573', '蓝':'#1e90ff', '紫':'#be2edd', '黑':'#2f3542', '白':'#ffffff' };
      const _COLOR_NAMES = Object.keys(_COLORS_DATA);
      const _DIFFICULTY_SETTINGS = {
        easy:   { time: Infinity, choices: 4, label: '简单' },
        medium: { time: 5000, choices: 4, label: '中等' },
        hard:   { time: 3000, choices: 6, label: '困难' }
      };
      
      let _gameState = {};

      function _resetGameState() {
          _gameState = { isRunning: false, difficulty: 'medium', totalCount: 10, currentCount: 0, score: 0, correctAnswer: '', timerId: null, roundStartTime: 0, correctCount: 0, reactionTimes: [] };
      }
      const _randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
      const _shuffleArray = (arr) => arr.sort(() => Math.random() - 0.5);

      function _switchScreen(from, to, onComplete = null) {
          if (from) from.classList.add('hidden');
          
          setTimeout(() => {
              if (from) from.style.display = 'none';
              if (to) {
                  const isFlexContainer = ['gameScreen', 'analysisReportContainer', 'controlContainer', 'completionContainer'].includes(to.id);
                  to.style.display = isFlexContainer ? 'flex' : 'block';
                  if(isFlexContainer) {
                      to.style.flexDirection = 'column';
                      to.style.alignItems = 'center';
                      to.style.justifyContent = 'center';
                  }
                  requestAnimationFrame(() => { 
                      to.classList.remove('hidden');
                      if (onComplete) onComplete();
                  });
              }
          }, 400);
      }
      
      function startGame() {
        if (_gameState.isRunning) return;
        _resetGameState();
        _gameState.isRunning = true;
        _gameState.difficulty = elements.difficultySelect.value;
        _gameState.totalCount = Math.max(1, parseInt(elements.totalCountInput.value) || 10);
        
        _switchScreen(elements.controlContainer, elements.gameScreen);

        updateProgress(0);
        setTimeout(nextRound, 500);
      }

      function stopGame() {
          if (!_gameState.isRunning) return;
          _gameState.isRunning = false;
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
          _switchScreen(elements.gameScreen, elements.controlContainer);
          _resetGameState();
      }

      function nextRound() {
        if (!_gameState.isRunning) return;
        if (_gameState.currentCount >= _gameState.totalCount) { endGame(); return; }
        clearForNextRound();
        let wordIndex, colorIndex;
        do { wordIndex = _randInt(0, _COLOR_NAMES.length - 1); colorIndex = _randInt(0, _COLOR_NAMES.length - 1); } while (wordIndex === colorIndex);
        
        const currentWord = _COLOR_NAMES[wordIndex];
        const currentColor = _COLORS_DATA[_COLOR_NAMES[colorIndex]];
        _gameState.correctAnswer = _COLOR_NAMES[colorIndex];
        
        elements.colorWord.textContent = currentWord;
        elements.colorWord.style.color = currentColor;
        elements.colorWord.classList.add('anim-enter');

        const choices = generateChoices(_gameState.correctAnswer, _DIFFICULTY_SETTINGS[_gameState.difficulty].choices);
        choices.forEach((choiceText, index) => {
            const btn = document.createElement('button');
            btn.className = 'choice-btn';
            btn.textContent = choiceText;
            btn.onclick = (e) => handleChoice(e.target);
            elements.choiceContainer.appendChild(btn);
            btn.style.animationDelay = `${index * 80}ms`;
            btn.classList.add('anim-enter');
        });
        startTimer();
      }
      
      function handleChoice(buttonElement) {
          if (!_gameState.isRunning || Array.from(elements.choiceContainer.children).some(c => c.disabled)) return;
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
          document.querySelectorAll('.choice-btn').forEach(b => b.disabled = true);

          _gameState.currentCount++;
          const selectedAnswer = buttonElement.textContent;
          let isCorrect = selectedAnswer === _gameState.correctAnswer;
          let pointsAdded = 0;

          if (isCorrect) {
              _gameState.correctCount++;
              const timeTaken = performance.now() - _gameState.roundStartTime;
              const timeLimit = _DIFFICULTY_SETTINGS[_gameState.difficulty].time;
              let basePoints = 100, timeBonus = 0;
              if(timeLimit !== Infinity) {
                  _gameState.reactionTimes.push(timeTaken);
                  timeBonus = Math.max(0, Math.floor((1 - timeTaken / timeLimit) * 50));
              }
              pointsAdded = basePoints + timeBonus;
              _gameState.score += pointsAdded;
              triggerFeedbackFlash(true);
              triggerFragments(_COLORS_DATA[_gameState.correctAnswer]);
              elements.colorWord.classList.add('correct-feedback');
          } else {
              elements.colorWord.classList.add('incorrect-feedback');
              triggerFeedbackFlash(false);
          }

          updateProgress(pointsAdded);
          setTimeout(nextRound, 1000);
      }

      function endGame() {
          _gameState.isRunning = false;
          _switchScreen(elements.gameScreen, elements.completionContainer);
          saveCurrentRecord();
          setTimeout(showAnalysisReport, 2500);
      }
      
      function clearForNextRound() {
          elements.choiceContainer.innerHTML = '';
          elements.colorWord.className = 'color-word';
          if(_gameState.timerId) clearTimeout(_gameState.timerId);
      }

      function generateChoices(correctAnswer, numChoices) {
          let choices = new Set([correctAnswer]);
          while(choices.size < numChoices) choices.add(_COLOR_NAMES[_randInt(0, _COLOR_NAMES.length - 1)]);
          return _shuffleArray(Array.from(choices));
      }
      
      function startTimer() {
          const timeLimit = _DIFFICULTY_SETTINGS[_gameState.difficulty].time;
          if (timeLimit === Infinity) { elements.timerFill.style.width = '100%'; return; }
          _gameState.roundStartTime = performance.now();
          elements.timerFill.style.transition = 'none';
          elements.timerFill.style.width = '100%';
          requestAnimationFrame(() => {
            setTimeout(() => {
                elements.timerFill.style.transition = `width ${timeLimit / 1000}s linear`;
                elements.timerFill.style.width = '0%';
            }, 50);
          });
          _gameState.timerId = setTimeout(() => { handleChoice({ textContent: null }); }, timeLimit);
      }

      function updateProgress(points) {
        elements.scoreDisplay.textContent = `得分: ${_gameState.score}`;
        elements.scoreDisplay.classList.remove('anim-update');
        void elements.scoreDisplay.offsetWidth;
        elements.scoreDisplay.classList.add('anim-update');
        if (points > 0) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${points}`;
            elements.progressWrapper.appendChild(popup);
            setTimeout(() => popup.remove(), 800);
        }
        const pct = _gameState.totalCount > 0 ? (_gameState.currentCount / _gameState.totalCount) * 100 : 0;
        elements.progressFill.style.width = pct + '%';
      }
      
      function getRecords() { return JSON.parse(localStorage.getItem('stroopChallengeHistory_G1.6')) || []; }
      function saveRecords(records) { localStorage.setItem('stroopChallengeHistory_G1.6', JSON.stringify(records)); }

      function calculateCEI(record) {
        if (!record) return 0;
        const accuracyFactor = record.accuracy;
        const avgTimeSeconds = record.avgTime > 0 ? record.avgTime / 1000 : 2.5;
        const speedFactor = Math.min(2.5, avgTimeSeconds);
        return Math.round(accuracyFactor * (100 / (speedFactor + 0.5)) * 1.5);
      }
      
      function saveCurrentRecord() {
        const accuracy = _gameState.totalCount > 0 ? _gameState.correctCount / _gameState.totalCount : 0;
        const avgTime = _gameState.reactionTimes.length > 0 ? _gameState.reactionTimes.reduce((a, b) => a + b, 0) / _gameState.reactionTimes.length : 0;
        const record = { timestamp: Date.now(), score: _gameState.score, accuracy: accuracy, avgTime: avgTime, difficulty: _gameState.difficulty, totalCount: _gameState.totalCount, reactionTimes: _gameState.reactionTimes };
        record.cei = calculateCEI(record);
        const records = getRecords();
        records.push(record);
        saveRecords(records);
      }

      function showAnalysisReport() {
        const allRecords = getRecords();
        const lastRecord = allRecords[allRecords.length - 1];
        if (!lastRecord) return;
        
        const profile = getCognitiveProfile(lastRecord);
        const profileType = getProfileType(profile);

        elements.summaryScore.textContent = lastRecord.score;
        elements.summaryCEI.textContent = lastRecord.cei;
        elements.summaryAvgTime.textContent = lastRecord.avgTime > 0 ? (lastRecord.avgTime / 1000).toFixed(2) + 's' : 'N/A';
        elements.summaryAccuracy.textContent = (lastRecord.accuracy * 100).toFixed(0) + '%';
        
        elements.profileTypeName.textContent = profileType.name;
        elements.summaryInsight.innerHTML = generatePersonalizedInsight(profile, profileType);
        
        elements.reportSummary.textContent = `本次 ${_DIFFICULTY_SETTINGS[lastRecord.difficulty].label} 难度, 共 ${lastRecord.totalCount} 题`;
        
        displayRecordsList(allRecords);

        _switchScreen(elements.completionContainer, elements.analysisReportContainer, () => {
            displayRadarChart(profile);
            displayTrendChart(allRecords);
            setupTabs();
        });
      }
      
      function displayRadarChart(profile) {
          const svg = elements.cognitiveProfileChart;
          svg.innerHTML = '';
          const size = Math.min(svg.clientWidth, svg.clientHeight);
          if(size === 0) return;
          const center = size / 2;
          const radius = size * 0.38;
          const levels = 4;
          const labels = Object.keys(profile);
          const numAxes = labels.length;

          for (let i = 1; i <= levels; i++) {
              const r = radius * (i / levels);
              let points = [];
              for (let j = 0; j < numAxes; j++) {
                  const angle = (j / numAxes) * 2 * Math.PI - Math.PI / 2;
                  points.push(`${center + r * Math.cos(angle)},${center + r * Math.sin(angle)}`);
              }
              svg.appendChild(createSVGElement('polygon', { points: points.join(' '), class: 'radar-grid' }));
              if (i % 2 === 0) {
                 const scaleLabel = createSVGElement('text', { x: center, y: center - r - 4, class: 'radar-scale-labels' });
                 scaleLabel.textContent = i * 25;
                 svg.appendChild(scaleLabel);
              }
          }

          labels.forEach((label, i) => {
              const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2;
              const x2 = center + radius * Math.cos(angle);
              const y2 = center + radius * Math.sin(angle);
              svg.appendChild(createSVGElement('line', { x1: center, y1: center, x2, y2, class: 'radar-axis' }));
              const lx = center + (radius + 20) * Math.cos(angle);
              const ly = center + (radius + 20) * Math.sin(angle);
              const text = createSVGElement('text', { x: lx, y: ly, class: 'radar-labels' });
              text.textContent = profile[label].label;
              svg.appendChild(text);
          });
          
          let dataPoints = [];
          labels.forEach((label, i) => {
              const value = profile[label].score / 100;
              const angle = (i / numAxes) * 2 * Math.PI - Math.PI / 2;
              const x = center + radius * value * Math.cos(angle);
              const y = center + radius * value * Math.sin(angle);
              dataPoints.push(`${x},${y}`);
              svg.appendChild(createSVGElement('circle', { cx: x, cy: y, r: 4, class: 'radar-point' }));
          });
          
          const area = createSVGElement('polygon', { points: dataPoints.join(' '), class: 'radar-area' });
          const initialPoints = new Array(numAxes).fill(`${center},${center}`).join(' ');
          area.innerHTML = `<animate attributeName="points" from="${initialPoints}" to="${dataPoints.join(' ')}" dur="0.7s" fill="freeze" calcMode="spline" keySplines="0.25 0.1 0.25 1" />`;
          svg.appendChild(area);
      }
      
      function displayTrendChart(records) {
        const svg = elements.trendChart;
        svg.innerHTML = '';
        const recentRecords = records.slice(-15);
        if (recentRecords.length < 2) { svg.innerHTML = '<text x="50%" y="50%" fill="white" text-anchor="middle">完成更多挑战以生成趋势图...</text>'; return; }

        const { width, height } = svg.getBoundingClientRect();
        if(width === 0) return;
        const padding = { top: 20, right: 35, bottom: 30, left: 30 };
        const data = recentRecords.map(r => r.cei);
        
        const maxVal = Math.ceil(Math.max(...data, 0) / 10) * 10;
        const minVal = 0;
        const avgVal = data.reduce((a, b) => a + b, 0) / data.length;

        const getX = (i) => padding.left + (width - padding.left - padding.right) * (i / (data.length - 1));
        const getY = (val) => height - padding.bottom - (height - padding.top - padding.bottom) * ((val - minVal) / (maxVal - minVal || 1));

        const yAxis = createSVGElement('g', { class: 'chart-axis' });
        [minVal, Math.round(avgVal), maxVal].forEach(val => {
          if (isNaN(val) || val > maxVal) return;
          const y = getY(val);
          yAxis.appendChild(createSVGElement('line', { x1: padding.left, y1: y, x2: width - padding.right, y2: y, class: 'chart-axis-line', 'stroke-dasharray': val === Math.round(avgVal) ? '4,4' : '2,2', 'stroke': val === Math.round(avgVal) ? '#879aff' : 'rgba(255,255,255,0.3)' }));
          const text = createSVGElement('text', { x: padding.left - 5, y: y + 4, class: 'chart-axis-text', 'text-anchor': 'end' });
          text.textContent = val;
          yAxis.appendChild(text);
        });
        svg.appendChild(yAxis);
        
        const xAxis = createSVGElement('g', { class: 'chart-axis' });
        data.forEach((_, i) => {
            const x = getX(i);
            const text = createSVGElement('text', { x: x, y: height - padding.bottom + 15, class: 'chart-axis-text', 'text-anchor': 'middle' });
            text.textContent = `#${records.length - recentRecords.length + i + 1}`;
            xAxis.appendChild(text);
        });
        svg.appendChild(xAxis);
        
        const defs = createSVGElement('defs');
        const gradient = createSVGElement('linearGradient', { id: 'chartGradient', x1: '0%', y1: '0%', x2: '0%', y2: '100%' });
        gradient.innerHTML = `<stop offset="0%" stop-color="#4ecdc4" stop-opacity="0.6"/> <stop offset="100%" stop-color="#4ecdc4" stop-opacity="0"/>`;
        defs.appendChild(gradient);
        svg.appendChild(defs);

        let linePath = `M ${getX(0)} ${getY(data[0])}`;
        let areaPath = `M ${getX(0)} ${height - padding.bottom} L ${getX(0)} ${getY(data[0])}`;
        for (let i = 1; i < data.length; i++) {
            linePath += ` L ${getX(i)} ${getY(data[i])}`;
            areaPath += ` L ${getX(i)} ${getY(data[i])}`;
        }
        areaPath += ` L ${getX(data.length-1)} ${height - padding.bottom} Z`;

        svg.appendChild(createSVGElement('path', { d: areaPath, class: 'chart-area' }));
        svg.appendChild(createSVGElement('path', { d: linePath, class: 'chart-line' }));

        data.forEach((val, i) => {
          const point = createSVGElement('circle', { cx: getX(i), cy: getY(val), r: 4, class: 'chart-point' });
          point.innerHTML = `<title>第${records.length - recentRecords.length + i + 1}次 - CEI: ${val}</title>`;
          svg.appendChild(point);
        });
      }

      function displayRecordsList(records) {
        elements.recordsList.innerHTML = '';
        if (records.length === 0) {
            elements.recordsList.innerHTML += '<div style="text-align:center; padding: 20px; color: rgba(255,255,255,0.7);">暂无记录</div>';
            return;
        }
        const pbScore = Math.max(...records.map(r => r.score));
        const recentRecords = records.slice().reverse().slice(0, 10);
        recentRecords.forEach(r => {
            const isPb = r.score === pbScore;
            const item = document.createElement('div');
            item.className = 'record-item' + (isPb ? ' is-pb' : '');
            item.innerHTML = `
                <div>
                    <div class="record-details-main">${_DIFFICULTY_SETTINGS[r.difficulty].label} - ${r.totalCount}题</div>
                    <div class="record-details-sub">
                        <span>${new Date(r.timestamp).toLocaleDateString()}</span>
                        <span>准确率: ${(r.accuracy * 100).toFixed(0)}%</span>
                        <span>反应: ${r.avgTime > 0 ? (r.avgTime/1000).toFixed(2)+'s' : 'N/A'}</span>
                    </div>
                </div>
                <div class="record-stats">CEI: ${r.cei}</div>`;
            elements.recordsList.appendChild(item);
        });
      }

      // --- Cognitive Model & Analysis ---
      function getCognitiveProfile(record) {
          const accuracyScore = record.accuracy * 100;
          const speedScore = Math.max(0, Math.min(100, 100 - ((record.avgTime || 2500) - 500) / 20));
          const stdDev = getStandardDeviation(record.reactionTimes);
          const consistencyScore = Math.max(0, Math.min(100, 100 - ((stdDev || 500) - 50) / 4.5));
          const flexibilityScore = (accuracyScore * 0.5) + (speedScore * 0.5);

          return {
              inhibitoryControl: { label: "抑制控制", score: accuracyScore },
              processingSpeed: { label: "加工速度", score: speedScore },
              performanceConsistency: { label: "表现一致性", score: consistencyScore },
              cognitiveFlexibility: { label: "认知灵活性", score: flexibilityScore },
          };
      }

      function getProfileType(profile) {
          const ic = profile.inhibitoryControl.score;
          const ps = profile.processingSpeed.score;
          const pc = profile.performanceConsistency.score;
          
          if (ps > 85 && ic > 90) return { name: "敏锐反应者", description: "您拥有闪电般的反应速度和出色的抗干扰能力。" };
          if (pc > 85 && ic > 85) return { name: "沉稳策略家", description: "您表现稳定，准确率高，展现出冷静和专注的特质。" };
          if (ic > 80 && ps > 80 && pc > 80) return { name: "均衡全能型", description: "您的各项认知能力均衡发展，综合表现优秀。" };
          if (ic > 90 && ps < 70) return { name: "细致思考者", description: "您追求极致的准确性，表现出严谨细致的思维风格。" };
          return { name: "潜力发展型", description: "您在本次挑战中展现了潜力，持续练习将带来显著提升。" };
      }
      
      function generatePersonalizedInsight(profile, profileType) {
          let insightHTML = `<p>${profileType.description}</p>`;
          const scores = Object.values(profile).sort((a,b) => b.score - a.score);
          const strongest = scores[0];
          const weakest = scores[scores.length - 1];

          insightHTML += `<p style="margin-top:10px;"><strong>优势分析:</strong> 您的「${strongest.label}」表现突出 (${Math.round(strongest.score)}分)，这说明您能高效地处理任务并保持专注。</p>`;
          insightHTML += `<p><em>提升建议:</em> 关注「${weakest.label}」(${Math.round(weakest.score)}分)的练习，尝试在保证速度的同时维持稳定表现，可以帮助您获得更全面的提升。</p>`;

          return insightHTML;
      }

      function getStandardDeviation(array) {
        if (!array || array.length < 2) return 0;
        const n = array.length;
        const mean = array.reduce((a, b) => a + b) / n;
        return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
      }
      
      function createSVGElement(tag, attrs) {
        const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const key in attrs) { el.setAttribute(key, attrs[key]); }
        return el;
      }
      
      function setupTabs() {
          const tabContainer = document.querySelector('.analysis-details');
          const tabBtns = tabContainer.querySelectorAll('.tab-btn');
          const tabPanes = tabContainer.querySelectorAll('.tab-pane');

          tabBtns.forEach(btn => {
              btn.addEventListener('click', () => {
                  tabBtns.forEach(b => b.classList.remove('active'));
                  btn.classList.add('active');
                  const targetTab = btn.getAttribute('data-tab');
                  tabPanes.forEach(pane => {
                      pane.classList.remove('active');
                      if(pane.id === `${targetTab}TabPane`) {
                          pane.classList.add('active');
                      }
                  });
              });
          });
      }

      function init() {
          const canvas = elements.fragmentCanvas;
          _resetGameState();
          createFloatingParticles();
          const resizeCanvas = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
          resizeCanvas();
          elements.startBtn.addEventListener('click', startGame);
          elements.stopBtn.addEventListener('click', stopGame);
          elements.playAgainBtn.addEventListener('click', () => { 
            _switchScreen(elements.analysisReportContainer, elements.controlContainer); 
          });
          elements.infoTrigger.addEventListener('click', () => elements.explanationModal.classList.add('visible'));
          elements.modalCloseBtn.addEventListener('click', () => elements.explanationModal.classList.remove('visible'));
          elements.explanationModal.addEventListener('click', (e) => {
             if (e.target === elements.explanationModal) elements.explanationModal.classList.remove('visible');
          });
          
          window.addEventListener('resize', () => {
              resizeCanvas();
              if (!elements.analysisReportContainer.classList.contains('hidden')) {
                  showAnalysisReport();
              }
          });
      }
      
      init();
    });
  </script>
</body>
</html>
